(function() {
  'use strict';

  angular.module('app', [
    'applicat.push.service',
    'ionic',
    'ngCordova',
    'ngResource',
    'ngTemplates',
    'ngStorage'
  ])

  .run([

    '$ionicPlatform', '$rootScope', '$stateParams', '$state', 'AuthService', '$window', '$ionicHistory', '$ionicSideMenuDelegate', 'Message', '$timeout', 'PushService', 'gpsService', 'appStorage',

    function($ionicPlatform, $rootScope, $stateParams, $state, AuthService, $window, $ionicHistory, $ionicSideMenuDelegate, Message, $timeout, PushService, gpsService, appStorage) {
      // $state.go('main.home.theme');
      // AuthService.init();
      $rootScope.goBack = function() {
        $ionicHistory.goBack();
      };

      $rootScope.appStorage = appStorage;

      $rootScope.isState = function(state) {
        return state === $ionicHistory.currentStateName();
      };

      $rootScope.isParam = function(paramObj) {
        for (var key in paramObj) {
          var value = paramObj[key];
          if ($stateParams[key] === value) {
            return true;
          }
        }
        return false;
      };


      // $state.go('main.home.theme');
      $rootScope.goToState = function(state, params) {
        $ionicSideMenuDelegate.toggleLeft(false);
        $state.go(state, params);
      };

      $rootScope.loading = function() {
        Message.loading();
        $timeout(function() {
          Message.hide();
        }, 2000);
      };

      $rootScope.$on('$stateChangeStart', function() {
        Message.loading();
      });

      $rootScope.$on('$stateChangeSuccess', function() {
        Message.hide();
      });

      function areStates(states) {
        console.log('states');
        console.log(states.indexOf($ionicHistory.currentStateName()) !== -1);
        return states.indexOf($ionicHistory.currentStateName()) !== -1;
      }

      $ionicPlatform.ready(function() {
        if ($window.cordova && $window.cordova.plugins.Keyboard) {
          $window.cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
          $state.go('main.home.theme');
          PushService.registerDevice();
        }
        if ($window.StatusBar) {
          $window.StatusBar.styleDefault();
        }
        if ($window.cordova) {
          gpsService.checkGPS();
          $state.go('main.home.theme');
        }
        $ionicPlatform.registerBackButtonAction(function(e) {
          e.preventDefault();
          if (areStates(['main.detail'])) {
            appStorage.isBackViewDetail = true;
            return $ionicHistory.goBack();
          } else if (areStates(['main.place.list'])) {
            $state.go('main.home.theme');
            return;
          }
          $ionicHistory.goBack();
        }, 101);

        // $ionicPlatform.registerBackButtonAction(function(e) {

        //   console.log('gogo');
        //   // console.log($rootScope.isState('admin'));
        //   e.preventDefault();

        //   if ($rootScope.isState('admin')) {
        //     console.log('gogo admin');
        //     return $state.go('main.home.theme');
        //   }
        //   $ionicHistory.goBack();
        // }, 101);

      });
    }
  ])

  .config([

    '$stateProvider', '$httpProvider', '$ionicConfigProvider',

    function($stateProvider, $httpProvider, $ionicConfigProvider) {

      // Security handler
      $httpProvider.interceptors.push('AuthInterceptor');
      // $ionicConfigProvider.views.forwardCache(true);
      // $ionicConfigProvider.views.swipeBackEnabled(false);
      // Allow session
      // $httpProvider.defaults.withCredentials = true;
      $stateProvider

        .state('main.admin', {
          url: '/admin',
          views: {
            main: {
              templateUrl: 'state/admin/admin.html',
              controller: 'AdminController as Admin'
            }
          }
        })
        .state('adminMenu', {
          url: '/adminMenu',
          templateUrl: 'state/adminMenu/adminMenu.html',
          controller: 'AdminMenuController as AdminMenu'
        })

      .state('login', {
        url: '/login',
        templateUrl: 'state/login/login.html',
        controller: 'LoginController as Login'
      })

      .state('signup', {
        url: '/signup',
        templateUrl: 'state/signup/signup.html',
        controller: 'SignupController as Signup'
      })

      .state('eventRegister', {
        url: '/eventRegister/:id',
        templateUrl: 'state/eventRegister/eventRegister.html',
        controller: 'EventRegisterController as EventRegister'
      })


      .state('main.daumMap', {
        url: '/daumMap/:id',
        views: {
          main: {
            templateUrl: 'state/daumMap/daumMap.html',
            controller: 'DaumMapController as Map'
          }
        }
      })

      .state('main', {
        // abstract: true,
        url: '/main',
        templateUrl: 'state/main/main.html',
        controller: 'MainController as Main'
      })

      .state('main.home', {
          // abstract: true,
          url: '/home',
          views: {
            main: {
              templateUrl: 'state/mainHome/home.html',
              controller: 'HomeController as Home'
            }
          }
        })
        .state('main.home.theme', {
          url: '/theme',
          views: {
            home: {
              templateUrl: 'state/mainHomeTheme/theme.html',
              controller: 'ThemeController as Theme'
            }
          }
        })
        .state('main.home.type', {
          url: '/type',
          views: {
            home: {
              templateUrl: 'state/mainHomeType/type.html',
              controller: 'TypeController as Type'
            }
          }
        })
        .state('main.home.location', {
          url: '/location',
          views: {
            home: {
              templateUrl: 'state/mainHomeLocation/location.html',
              controller: 'LocationController as Location'
            }
          }
        })

      .state('main.detail', {
        url: '/detail/:id',
        views: {
          main: {
            templateUrl: 'state/mainPlaceDetail/detail.html',
            controller: 'DetailController as Detail'
          }
        }
      })

      .state('main.event', {
          url: '/event',
          views: {
            main: {
              templateUrl: 'state/mainEvent/event.html',
              controller: 'EventController as Event'
            }
          }
        })
        .state('main.event.list', {
          url: '/list/:eventType',
          views: {
            event: {
              templateUrl: 'state/mainEventList/list.html',
              controller: 'EventListController as EventList'
            }
          }
        })
        .state('main.eventDetail', {
          url: '/eventDetail/:id',
          views: {
            main: {
              templateUrl: 'state/mainEventDetail/eventDetail.html',
              controller: 'EventDetailController as EventDetail'
            }
          }
        })

      .state('main.place', {
          url: '/place/:category',
          views: {
            main: {
              templateUrl: 'state/mainPlace/place.html',
              // controller: 'PlaceController as Place'
            }
          }
        })
        .state('main.place.list', {
          url: '/:from/list',
          views: {
            place: {
              templateUrl: 'state/mainPlaceList/placeList.html',
              controller: 'PlaceListController as PlaceList'
            }
          }
        })

      .state('placeSearch', {
        url: '/placeSearch',
        templateUrl: 'state/placeSearch/placeSearch.html',
        controller: 'PlaceSearchController as PlaceSearch'
      })

      .state('main.noticeList', {
        url: '/noticeList',
        views: {
          main: {
            templateUrl: 'state/mainNoticeList/noticeList.html',
            controller: 'NoticeListController as NoticeList'
          }
        }
      })

      .state('main.noticeDetail', {
        url: '/noticeDetail/:id',
        views: {
          main: {
            templateUrl: 'state/mainNoticeDetail/noticeDetail.html',
            controller: 'NoticeDetailController as NoticeDetail'
          }
        }
      })

      .state('main.association', {
        url: '/association',
        views: {
          main: {
            templateUrl: 'state/mainAssociation/association.html',
            controller: 'AssociationController as Association'
          }
        }
      })

      .state('main.contract', {
        url: '/contract',
        views: {
          main: {
            templateUrl: 'state/mainContract/contract.html'
              // controller: 'ContractController as Contract'
          }
        }
      })

      .state('main.customer', {
        url: '/customer',
        views: {
          main: {
            templateUrl: 'state/mainCustomer/customer.html',
            controller: 'CustomerController as Customer'
          }
        }
      });

    } //END
  ]);

})();

(function() {
    'use strict';

    angular.module('app')
        .factory('daum', daum);

    daum.$inject = ['$window'];

    function daum($window) {

        if ($window.daum) {
            return $window.daum;
        }
        return;
    }
})();

(function() {
  'use strict';

  angular.module('app')
    .factory('geolib', geolib);

  geolib.$inject = ['$window'];

  function geolib($window) {

    return $window.geolib;

  }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('localStorage', localStorage);

    localStorage.$inject = ['$window'];

    function localStorage($window) {

        if ($window.localStorage) {
            return $window.localStorage;
        }
        return;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('moment', moment);

    moment.$inject = ['$window'];

    function moment($window) {

        return $window.moment;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('_', _);

    _.$inject = ['$window'];

    function _($window) {

        if ($window._) {
            return $window._;
        }
        return;
    }
})();

(function() {
  'use strict';

  angular.module('app')
    .constant("governorUrl", "http://hungers.applicat.co.kr")
  // .constant("governorUrl", "http://192.168.43.119:1337")
  // .constant("governorUrl", "http://192.168.0.65:1337")
  .constant("appName", "hungers")
    .constant("googlePushSenderID", "774642871236")
    .constant("kakaoKey", "bdb254de02ea0b7521635ba469608674")
    .constant("facebookKey", "801820753200919");
  // .constant("appId", 3)

})();

(function() {
  'use strict';

  angular.module('applicat.push.service', ['ngCordova'])
    .service('PushService', PushService);

  PushService.$inject = [
    '$http', '$log', '$q', '$cordovaDialogs', '$window',
    '$timeout', '$rootScope', '$cordovaMedia',
    'googlePushSenderID', 'governorUrl'
  ];

  function PushService(
    $http, $log, $q, $cordovaDialogs, $window,
    $timeout, $rootScope, $cordovaMedia,
    googlePushSenderID, governorUrl
  ) {
    var deviceId = null;

    this.registerDevice = registerDevice;
    // maybe devideId is used outside of this service, or not...
    this.getDeviceId = function() {
      return deviceId;
    };

    //====================================================
    //  Implementation
    //====================================================
    function registerDevice() {
      var push = $window.PushNotification.init({
        android: {
          "senderID": googlePushSenderID
        },
        ios: {
          "badge": true,
          "sound": "true",
          "alert": "true"
        }
      });

      if (ionic.Platform.isIOS()) {
        push.getApplicationIconBadgeNumber(function(n) {
          push.setApplicationIconBadgeNumber(function() {
            console.log('---- setApplicationBadegeNumber success with ' + n + ' ----');
          }, function() {
            console.log('----- setApplicationBadgeNumber error -----');
          }, n);
        }, function() {
          console.log('---- getBadgeNumber error ----');
        });
      }

      push.on('registration', function(result) {
        if (ionic.Platform.isIOS()) {
          storeDeviceToken(result.registrationId, 'IOS');
        } else if (ionic.Platform.isAndroid()) {
          storeDeviceToken(result.registrationId, 'ANDROID');
        }
      });

      push.on('notification', function(notification) {
        if (ionic.Platform.isAndroid()) {
          $window.plugin.notification.local.schedule({
            title: notification.title,
            text: notification.message,
            icon: "res://icon.png",
            smallIcon: "res://pushicon.png"
          });
        } else if (ionic.Platform.isIOS()) {
          handleIOS(notification);
        }
      });
    }

    //====================================================
    //  Helpers
    //====================================================
    function storeDeviceToken(deviceId, deviceType) {
      var registration = {
        deviceId: deviceId,
        platform: deviceType,
        active: true
      };
      return $http({
          url: governorUrl + '/device',
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          data: registration
        })
        .then(function(dataWrapper) {
          $log.info("PushService - registered to server: " + JSON.stringify(dataWrapper));
          deviceId = dataWrapper.data.device.deviceId;
        })
        .catch(function(err) {
          $log.info("PushService - error: " + JSON.stringify(err));
        });
    }


    function handleIOS(notification) {
      // If foreground is not checked here it would make a sound twice,
      //once when received in background and once more upon opening it by clicking
      //the notification.
      if (notification.additionalData.foreground === true) {
        // Play custom audio if a sound specified.
        if (notification.sound) {
          var audio = $cordovaMedia.newMedia(notification.sound);
          audio.then(function(r) {
            console.log('success');
            console.log(r);
            $timeout(function() {
              audio.play();
            }, 500);
          }, function(r) {
            console.log('error');
            console.log(r);
          });
        }
        $cordovaDialogs.alert(notification.title, notification.message);
      } else {
        $cordovaDialogs.alert(notification.title, notification.message);
      }
    }
  }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('appStorage', appStorage);

    appStorage.$inject = ['$localStorage', 'appName'];

    function appStorage($localStorage, appName) {
        if (!$localStorage[appName]) {
            $localStorage[appName] = {};
        }
        return $localStorage[appName];
    }
})();

(function() {
  'use strict';

  angular.module('app')
    .factory('AuthInterceptor', AuthInterceptor);

  AuthInterceptor.$inject = ['$q', '$injector', '$location', 'LocalService', 'appName', 'appStorage'];

  function AuthInterceptor($q, $injector, $location, LocalService, appName, appStorage) {

    return {
      request: function(req) {

          // var token = LocalService.get(appName + '_auth_token');
          var token = appStorage.token;

          // if (token) {
          //     token = angular.fromJson(LocalService.get(appName + '_auth_token')).token;
          // }

          if (token) {
            req.headers['Content-Type'] = 'application/json';
            req.headers.Authorization = 'Bearer ' + token;
          }
          return req;
        }
        // , responseError: function(response) {
        //     if (response.status === 401 || response.status === 403 || response.status === 405 || response.status === 498) {

      //         if ($location.path() !== "/login") {

      //             var appToken = appName + '_auth_token';
      //             delete $localStorage[appToken];
      //             // LocalService.unset(appName + '_auth_token');
      //             $location.path("/login");

      //             if (response.data == null) {
      //                 response.data = {
      //                     message: "권한이 없는 페이지이거나 로그인하지 않았습니다. 로그인해주세요."
      //                 };
      //             }
      //         } else {
      //             response.data.hideMessage = true;
      //         }
      //     } else if (response.status === 300) {

      //         var redirectPath = null;
      //         var message = '';
      //         switch (response.data.redirectCode) {
      //             case 'ACTIVATE':
      //                 redirectPath = "/resend/false";
      //                 message: "이메일 인증을 하셔야 서비스 이용이 가능합니다.";
      //                 break;
      //             case 'RESET':
      //                 redirectPath = "/passReset";
      //                 message: "비밀번호를 봐꿔주세요.";
      //                 break;
      //         }

      //         if ($location.path() !== redirectPath) {

      //             $location.path(redirectPath);

      //             if (response.data == null) {
      //                 response.data = {
      //                     message: message
      //                 };
      //             }
      //         } else {
      //             response.data.hideMessage = true;
      //         }
      //     }
      //     return $q.reject(response);
      // }
    };
  }


  angular.module('app')
    .service("AuthService", AuthService);
  // , '$cordovaOauth', $cordovaOauth
  AuthService.$inject = ['$http', '$q', '$location', '$state', 'governorUrl', 'LocalService', 'appName', 'kakaoKey', 'facebookKey'];

  function AuthService($http, $q, $location, $state, governorUrl, LocalService, appName, kakaoKey, facebookKey) {

    // var user = null;
    // var selectedApp = {
    //     name: '어플리켓'
    // };

    // function setUser(userInfo) {
    //     user = userInfo;
    // }

    // this.getUser = function() {
    //     return user;
    // }

    // function setApp(app) {
    //     $rootScope.appName = app.name;
    //     selectedApp = app;
    // }

    // this.getApp = function() {
    //     return selectedApp;
    // }

    // this.getToken = function() {
    //     var token = LocalService.get(appName + '_auth_token');

    //     if (token) {
    //         token = angular.fromJson(LocalService.get(appName + '_auth_token')).token;
    //         return token;
    //     } else {
    //         $state.go('login');
    //     }
    // }

    // this.init = function() {
    //     var token = JSON.parse(LocalService.get(appName + '_auth_token'));
    //     if (token != null && token.user != null)
    //         setUser(token.user);
    // }

    // this.register = function(user) {

    //     var deferred = $q.defer();

    //     $http({
    //         url: governorUrl + '/user/register',
    //         method: 'post',
    //         headers: {
    //             'Content-Type': 'application/json'
    //         },
    //         params: user
    //     })
    //         .success(function(data, status, headers, config) {
    //             deferred.resolve(data);
    //         })
    //         .error(function(data, status, headers, config) {
    //             deferred.reject(data);
    //         });
    //     return deferred.promise;
    // }

    this.registerWithImage = function(user, file, success, fail) {

      var options = new FileUploadOptions();

      var newUser = angular.copy(user);

      options.params = newUser;
      options.headers = {
        Connection: "close"
      }
      options.chunkedMode = false;

      var ft = new FileTransfer();

      ft.upload(file, encodeURI(governorUrl + '/user/registerWithImage'), success, fail, options, true);
    }

    // this.login = function(email, password) {

    //     var deferred = $q.defer();

    //     $http({
    //         url: governorUrl + '/auth/local',
    //         method: 'post',
    //         headers: {
    //             'Content-Type': 'application/json'
    //         },
    //         data: {
    //             'identifier': email,
    //             'password': password
    //         }
    //     })
    //         .success(function(data, status, headers, config) {

    //             console.log(data);
    //             LocalService.set(appName + '_auth_token', JSON.stringify(data));
    //             setUser(data.user);

    //             deferred.resolve(data);
    //         })
    //         .error(function(data, status, headers, config) {
    //             console.log(data);
    //             deferred.reject(data);
    //         });

    //     return deferred.promise;

    // }

    this.verifyResetCode = function(email, code) {

      var deferred = $q.defer();


      $http({
          url: governorUrl + '/user/passwordresetcomplete',
          method: 'put',
          headers: {
            'Content-Type': 'application/json'
          },
          data: {
            'email': email,
            'code': code
          }
        })
        .success(function(data, status, headers, config) {
          LocalService.set(appName + '_auth_token', JSON.stringify(data));
          deferred.resolve(data);
        })
        .error(function(data, status, headers, config) {
          deferred.reject(data);
        });

      return deferred.promise;

    }

    this.passReset = function(email) {

      var deferred = $q.defer();

      $http({
          url: governorUrl + '/user/resetStart',
          method: 'post',
          headers: {
            'Content-Type': 'application/json'
          },
          data: {
            'email': email
          }
        })
        .success(function(data, status, headers, config) {
          deferred.resolve(data);
        })
        .error(function(data, status, headers, config) {
          deferred.reject(data);
        });
      return deferred.promise;
    }

    // this.logout = function() {
    //     LocalService.unset(appName + '_auth_token');
    //     setUser(null);
    //     $location.path("/login");
    // }

    this.changePassword = function(oldPassword, newPassword) {

      var deferred = $q.defer();

      $http({
          url: governorUrl + '/user/changePassword',
          method: 'post',
          headers: {
            'Content-Type': 'application/json'
          },
          data: {
            'oldPassword': oldPassword,
            'newPassword': newPassword
          }
        })
        .success(function(data, status, headers, config) {
          deferred.resolve(data);
        })
        .error(function(data, status, headers, config) {
          deferred.reject(data);
        });

      return deferred.promise;
    }

    this.checkNickname = function(nickname) {

      var deferred = $q.defer();

      $http({
          url: governorUrl + '/user/checknickname',
          method: 'get',
          headers: {
            'Content-Type': 'application/json'
          },
          params: {
            nickname: nickname
          }
        })
        .success(function(data, status, headers, config) {
          deferred.resolve(data);
        })
        .error(function(data, status, headers, config) {
          deferred.reject(data);
        });
      return deferred.promise;
    }

    this.checkEmail = function(email) {

      var deferred = $q.defer();

      $http({
          url: governorUrl + '/user/checkEmail',
          method: 'get',
          headers: {
            'Content-Type': 'application/json'
          },
          params: {
            email: email
          }
        })
        .success(function(data, status, headers, config) {
          deferred.resolve(data);
        })
        .error(function(data, status, headers, config) {
          deferred.reject(data);
        });
      return deferred.promise;
    }

    this.getMyProfile = function() {
      var deferred = $q.defer();

      $http({
          url: governorUrl + '/user/profile',
          method: 'get',
          headers: {
            'Content-Type': 'application/json'
          },
        })
        .success(function(data, status, headers, config) {
          deferred.resolve(data);
        })
        .error(function(data, status, headers, config) {
          deferred.reject(data);
        });
      return deferred.promise;
    }

    this.updateMyProfile = function(nickname) {
      var deferred = $q.defer();

      $http({
          url: governorUrl + '/user/update',
          method: 'put',
          headers: {
            'Content-Type': 'application/json'
          },
          data: {
            nickname: nickname
          }
        })
        .success(function(data, status, headers, config) {
          deferred.resolve(data);
        })
        .error(function(data, status, headers, config) {
          deferred.reject(data);
        });
      return deferred.promise;
    }

    this.updateMyProfileWithImage = function(user, file, success, fail) {

      var options = new FileUploadOptions();

      var updateUser = angular.copy(user);

      options.params = updateUser;
      options.httpMethod = 'PUT';
      options.headers = {
        Connection: "close",
        Authorization: 'Bearer ' + this.getToken()
      }
      options.chunkedMode = false;

      var ft = new FileTransfer();

      ft.upload(file, encodeURI(governorUrl + '/user/updateWithImage'), success, fail, options, true);
    }


    // this.loginWithKakao = function() {

    //   var deferred = $q.defer();

    //   $cordovaOauth.kakao(kakaoKey).then(function(result) {
    //     result.provider = 'kakao';

    //     console.log('kakao server result');
    //     console.log(result);
    //     $http({
    //         url: governorUrl + '/auth/register',
    //         method: 'post',
    //         headers: {
    //           'Content-Type': 'application/json'
    //         },
    //         data: result
    //       })
    //       .success(function(data, status, headers, config) {

    //         LocalService.set(appName + '_auth_token', JSON.stringify(data));
    //         console.log('kakao response from server');
    //         console.log(JSON.stringify(data, null, 2));
    //         console.log(JSON.stringify(data.user, null, 2));
    //         setUser(data.user);

    //         deferred.resolve({
    //           message: 'done'
    //         });
    //       })
    //       .error(function(data, status, headers, config) {
    //         console.log(data);
    //         deferred.reject(data);
    //       });


    //   }, function(error) {
    //     deferred.reject(error);
    //   });

    //   return deferred.promise;
    // }

    // this.loginWithFacebook = function() {

    //   var deferred = $q.defer();

    //   $cordovaOauth.facebook(facebookKey, ["email"]).then(function(result) {
    //     result.provider = 'facebook';

    //     console.log('facebook server result');
    //     console.log(result);
    //     $http({
    //         url: governorUrl + '/auth/register',
    //         method: 'post',
    //         headers: {
    //           'Content-Type': 'application/json'
    //         },
    //         data: result
    //       })
    //       .success(function(data, status, headers, config) {

    //         LocalService.set(appName + '_auth_token', JSON.stringify(data));
    //         setUser(data.user);
    //         console.log('facebook response from our server');
    //         console.log(JSON.stringify(data, null, 2));
    //         console.log(JSON.stringify(data.user, null, 2));

    //         deferred.resolve({
    //           message: 'done'
    //         });
    //       })
    //       .error(function(data, status, headers, config) {
    //         console.log(data, status, headers, config);
    //         deferred.reject(data);
    //       });


    //   }, function(error) {
    //     deferred.reject(error);
    //   });

    //   return deferred.promise;
    // }





  }


})();

// Input:
//p1, p2, where p1,p2 = {latitude: float, longitude: float}

// Usage
// Distance.between({latitude: 33, longitude: 33}, {latitude: 44, longitude:44});

// Output: distance between two points in meters.
// 20000
(function() {
  'use strict';

  angular.module('app')
    .factory('Distance', Distance);

  Distance.$inject = ['geolib'];

  function Distance(geolib) {

    var service = {
      // between: haversine
      between: geolib.getDistance
    };

    return service;





    // //====================================================
    // //  IMPLEMENTATIONS
    // //====================================================
    // //p1, p2 = {latitude: 33, longitude: 33}
    // function haversine(p1, p2) {
    //     var R = 6371;
    //     var dLat = rad(p2.latitude - p1.latitude);
    //     var dLong = rad(p2.longitude - p1.longitude);

    //     var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    //         Math.cos(rad(p1.latitude)) * Math.cos(rad(p2.latitude)) * Math.sin(dLong / 2) * Math.sin(dLong / 2);
    //     var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    //     var d = R * c;

    //     var meters = Math.round(d * 1000);
    //     return meters;
    // }
    // //====================================================
    // //  HELPER
    // //====================================================
    // function rad(x) {
    //     return x * Math.PI / 180;
    // }

  }
})();

(function() {
  'use strict';

  angular.module('app')
    .factory('Dom', Dom);

  Dom.$inject = [
    '$timeout', '$window', '$ionicScrollDelegate', '$rootScope',
    'appStorage'
  ];

  function Dom(
    $timeout, $window, $ionicScrollDelegate, $rootScope,
    appStorage
  ) {
    var service = {
      focusById: focusById,
      menuScroller: menuScroller
    };

    return service;
    // <input id="daum-map-search-input" type="text">
    // Dom.focusById('daum-map-search-input');
    function focusById(id) {
      $timeout(function() {
        var domElement = $window.document.getElementById(id);
        if (domElement) {
          domElement.focus();
        }
      });
    }
    // <ion-scroll
    //     direction="x"
    //     scrollbar-x=false
    //     delegate-handle="categoryMenu"
    // >
    //     <ul class="category-ul">
    //         <li id="{{::category.id}}" class="category-li"
    //             ng-repeat="category in categories"
    //             ng-click="selectHandler(categories, 'categoryMenu', $index, $event, 2.8, category)">
    //             <h2>{{ category.location }}</h2>
    //         </li>
    //     </ul>
    // </ion-scroll>
    function menuScroller(arrayData, $index) {
      function calculatePixelToIndex(index) {
        var totalVw = 0;
        for (var i = 0; i < index; i++) {
          totalVw += arrayData[i].vw;
        }
        var totalPixelToIndex = (totalVw / 100) * $rootScope.windowWidth +
          ($rootScope.windowWidth / 2) +
          ((arrayData[index].vw / 100) * $rootScope.windowWidth / 2) -
          $rootScope.windowWidth;
        return totalPixelToIndex;
      }

      var pixelLocation = calculatePixelToIndex($index);
      console.log('this');
      console.log(pixelLocation);
      $timeout(function() {
        $ionicScrollDelegate.scrollTo(pixelLocation, appStorage.scrollPositionY, true);
      }, 0);
    }
  }

})();

// Dependencies;
// vm.styleFavorite
// model.current    // eg Detail.currentPost, Detail.currentPlace... rename to current
(function() {
    'use strict';

    angular.module('app')
        .factory('Favorite', Favorite);

    Favorite.$inject = ['$stateParams', 'Message', 'Posts', 'localStorage'];

    function Favorite($stateParams, Message, Posts, localStorage) {

        var service = {
            isFavorite: isFavorite,
            saveToFavorite: saveToFavorite
        };
        return service;

        //------------------------
        //  Implementations
        //------------------------
        function isFavorite(localStorageItem) {
            var favoritesString = localStorage.getItem(localStorageItem);
            var favoritesArray = angular.fromJson(favoritesString);
            if (!Array.isArray(favoritesArray)) {
                favoritesArray = [];
            }
            for (var i = 0; i < favoritesArray.length; i++) {
                var favorite = favoritesArray[i];
                if (favorite.id === $stateParams.id) {
                    return true;
                }
            }
        }

        function saveToFavorite(localStorageItem, vm, model, sendLikeStorageName) {
            var favoritesString = localStorage.getItem(localStorageItem);
            var favoritesArray = angular.fromJson(favoritesString);
            // If no item create empty bucket.
            if (!Array.isArray(favoritesArray)) {
                favoritesArray = [];
            }
            for (var i = 0; i < favoritesArray.length; i++) {
                var favorite = favoritesArray[i];
                // If current favorite exists;
                if (favorite.id === $stateParams.id) {
                    favoritesArray.splice(i, 1);
                    favoritesString = angular.toJson(favoritesArray);
                    localStorage.setItem(localStorageItem, favoritesString);
                    vm.styleFavorite = false;
                    Message.alert('즐겨찾기 알림', '즐겨찾기에서 삭제되었습니다.');
                    return false;
                }
            }
            // If current favorite does not exist then save;
            var favoriteToSave = {
                id: model.current.id,
            };

            addToAttributes(model, favoriteToSave);

            console.log(favoriteToSave);
            favoritesArray.push(favoriteToSave);
            favoritesString = angular.toJson(favoritesArray);
            localStorage.setItem(localStorageItem, favoritesString);
            if (sendLikeStorageName) {
                sendLike(sendLikeStorageName, favoriteToSave.id, model);
            }
            vm.styleFavorite = true;
            Message.alert('즐겨찾기 알림', '즐겨찾기에 추가되었습니다.');
        }

        function addToAttributes(model, favoriteToSave) {
            if (model.current.name) {
                favoriteToSave.name = model.current.name;
            }
            if (model.current.title) {
                favoriteToSave.title = model.current.title;
            }
            if (model.current.photos.length > 0) {
                favoriteToSave.photos = [{
                    url: model.current.photos[0].url
                }];
            }
            if (model.current.location) {
                favoriteToSave.location = {
                    coordinates: model.current.location.coordinates
                };
            }
            if (model.current.address) {
                favoriteToSave.address = model.current.address;
            }
            if (model.current.createdBy) {
                favoriteToSave.createdBy = {};
                favoriteToSave.createdBy.nickname = model.current.createdBy.nickname;
            }
            if (model.current.likes) {
                favoriteToSave.likes = model.current.likes;
            }
            if (model.current.comments) {
                favoriteToSave.comments = [];
                for (var i = 0; i < model.current.comments.length; i++) {
                    favoriteToSave.comments.push(1);
                }
            }
        }

        function sendLike(likedOnceStorageItem, id, model) {
            // add to liked once list
            var likedOnceString = localStorage.getItem(likedOnceStorageItem);
            var likedOnceArray = angular.fromJson(likedOnceString);
            if (!Array.isArray(likedOnceArray)) {
                likedOnceArray = [];
            }
            for (var i = 0; i < likedOnceArray.length; i++) {
                var currentId = likedOnceArray[i];
                if (currentId === id) {
                    return false;
                }
            }
            likedOnceArray.push(id);
            likedOnceString = angular.toJson(likedOnceArray);
            localStorage.setItem(likedOnceStorageItem, likedOnceString);
            Posts.likePost({
                post: id
            }).$promise
                .then(function success(postWrapper) {
                    console.log('thisdata');
                    console.log(postWrapper);
                    model.current.likes = postWrapper.posts[0].likes;
                }, function err(error) {
                    console.log(error);
                });
        }
    } // Service END
})();

(function() {
  'use strict';

  angular.module('app')
    .factory('gpsService', gpsService);

  gpsService.$inject = ['$cordovaGeolocation', 'Message', '_'];

  function gpsService($cordovaGeolocation, Message, _) {

    function getPosition() {
      console.log('test throttle');
      return $cordovaGeolocation.getCurrentPosition({
          maximumAge: 600000,
          timeout: 7000
        })
        .then(function success(position) {
          console.log(position);
        }, function geoError(error) {
          console.log(error);
          Message.alert(
            '위치 공유가 꺼져있습니다.',
            '위치 공유를 켜주세요.'
          );
        });
    }

    var checkGPS = _.throttle(getPosition, 8000, {
      trailing: false
    });

    var service = {
      checkGPS: checkGPS
    };

    return service;


  }
})();

(function() {
    'use strict';
    angular.module('app')
        .factory('LocalService', function() {
            return {
                get: function(key) {
                    return localStorage.getItem(key);
                },
                set: function(key, val) {
                    return localStorage.setItem(key, val);
                },
                unset: function(key) {
                    return localStorage.removeItem(key);
                },
                getSession: function(key) {
                    return sessionStorage.getItem(key);
                },
                setSession: function(key, val) {
                    return sessionStorage.setItem(key, val);
                },
                unsetSession: function(key) {
                    return sessionStorage.removeItem(key);
                }
            }
        });


})();

(function() {
    'use strict';
    angular.module('app')
        .factory('Message', Message);

    Message.$inject = ['$ionicLoading', '$ionicPopup'];

    function Message($ionicLoading, $ionicPopup) {
        var service = {
            loading: loadingDefault,
            hide: loadingHide,
            success: messageSuccess,
            error: messageError,
            alert: popUpAlertDefault
        };

        return service;

        function loadingDefault(message) {
            $ionicLoading.show(message);
        }

        function messageSuccess(message) {
            $ionicLoading.show({
                template: '<h4 class="message-success">' + message + '</h4>',
                duration: 2000
            });
        }

        function messageError(message) {
            $ionicLoading.show({
                template: '<h4 class="message-error">' + message + '</h4>',
                duration: 2000
            });
        }

        function loadingHide() {
            $ionicLoading.hide();
        }

        function popUpAlertDefault(title, message) {
            return $ionicPopup.alert({
                title: title || '인터넷이 끊겼습니다.',
                template: message || '인터넷을 켜주세요.'
            });
        }


    }


})();

/**
 * Created by Seunghoon Ko on 10/10/2015
 * As part of applicat platform
 *
 * Copyright (C) Applicat (www.applicat.co.kr) & Seunghoon Ko - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 * Written by Seunghoon Ko <imskojs@gmail.com>, 10/10/2015
 *
 */
(function() {
  'use strict';

  angular.module('app')
    .factory('U', U);

  U.$inject = [
    '$ionicHistory', '$ionicScrollDelegate', '$timeout', '_', '$filter',
    'Message', '$ionicSideMenuDelegate', '$state',
    '$ionicViewSwitcher', '$ionicSlideBoxDelegate'
  ];

  function U(
    $ionicHistory, $ionicScrollDelegate, $timeout, _, $filter,
    Message, $ionicSideMenuDelegate, $state,
    $ionicViewSwitcher, $ionicSlideBoxDelegate
  ) {

    var service = {
      isForwardView: isForwardView,
      isBackView: isBackView,
      isSiblingView: isSiblingView,
      areSiblingViews: areSiblingViews,
      resize: resize,
      update: update,
      resetSlides: resetSlides,
      reset: reset,
      goToState: goToState,
      goBack: goBack,
      error: error,
      bindData: bindData,
      appendData: appendData,
      broadcast: broadcast
    };

    return service;

    function isForwardView(stateName) {
      console.log($ionicHistory.viewHistory());
      var isView =
        $ionicHistory.viewHistory().forwardView &&
        $ionicHistory.viewHistory().forwardView.stateName === stateName;
      return isView;
    }

    function isBackView(stateName) {
      console.log($ionicHistory.viewHistory());
      var isView =
        $ionicHistory.viewHistory().backView &&
        $ionicHistory.viewHistory().backView.stateName === stateName;
      return isView;
    }

    function isSiblingView(stateName) {
      return isForwardView(stateName) || isBackView(stateName);
    }

    function areSiblingViews(stateNames) {
      var i;
      var stateName;
      for (i = 0; i < stateNames.length; i++) {
        stateName = stateNames[i];
        if (isSiblingView(stateName)) {
          return true;
        }
      }
      return false;
    }

    function resize() {
      $timeout(function() {
        $ionicScrollDelegate.resize();
      }, 0);
    }

    function update() {
      $timeout(function() {
        $ionicSlideBoxDelegate.update();
      }, 0);
    }

    function resetSlides() {
      $ionicSlideBoxDelegate.slide(0, 0);
      $ionicSlideBoxDelegate.update();
    }

    function reset(model) {
      for (var key in model) {
        if (Array.isArray(model[key])) {
          model[key] = [];
        } else if (model[key] !== null && typeof model[key] === 'object') {
          model[key] = {};
        } else if (typeof model[key] === 'boolean') {
          model[key] = false;
        } else {
          model[key] = null;
        }
      }
    }

    function goToState(state, params, direction) {
      Message.hide();
      $timeout(function() {
        if (direction) {
          $ionicViewSwitcher.nextDirection(direction);
        }
        $state.go(state, params);
        $ionicSideMenuDelegate.toggleLeft(false);
      }, 0);
    }

    function goBack(direction) {
      if (direction) {
        $ionicViewSwitcher.nextDirection(direction);
      }
      $ionicHistory.goBack();
    }

    function error(err) {
      Message.hide();
      Message.alert();
      console.log(err);
    }

    function bindData(data, model, name) {
      // if data is a dataWrapper
      if (name[name.length - 1] === 's') {
        model[name] = data[name];
        model.more = data.more;
        // if data is a data
      } else {
        model[name] = data;
      }
      resize();
      $timeout(function() {
        model.loading = false;
      }, 50);
    }

    function appendData(dataWrapper, model, name) {
      if (name[name.length - 1] === 's') {
        angular.forEach(dataWrapper[name], function(item) {
          model[name].push(item);
        });
        model.more = dataWrapper.more;
        resize();
        // if data is a data
      } else {
        console.error('no dataWrapper.data perhaps dataWrapper is data.');
      }
    }

    function broadcast($scope) {
      $scope.$broadcast('scroll.refreshComplete');
      $scope.$broadcast('scroll.infiniteScrollComplete');
    }

  } // Service END
})();

// Fixes the case where parent veritcal scrolling is disabled on ion-scroll
// element.

// Usage
// ion-scroll[direction="x" scroll-parent]
(function() {
    'use strict';

    angular.module('app')
        .directive('parentScroll', parentScroll);

    parentScroll.$inject = ['$ionicScrollDelegate', '$timeout', '$window'];

    function parentScroll($ionicScrollDelegate, $timeout, $window) {
        return {
            scope: true,
            restrict: 'A',
            compile: compile
        };

        function compile(element, attr) {

            if (!$window.horizontalIonScrollCount) {
                $window.horizontalIonScrollCount = 0;
            }

            $window.horizontalIonScrollCount++;
            attr.delegateHandle = "horizontal" + $window.horizontalIonScrollCount;

            return function(scope, element, attr) {
                $timeout(function() {
                    var horizontal = attr.delegateHandle;
                    var sv = $ionicScrollDelegate.$getByHandle(horizontal).getScrollView();

                    var container = sv.__container;

                    var originaltouchStart = sv.touchStart;
                    var originalmouseDown = sv.mouseDown;
                    var originaltouchMove = sv.touchMove;
                    var originalmouseMove = sv.mouseMove;

                    container.removeEventListener('touchstart', sv.touchStart);
                    container.removeEventListener('mousedown', sv.mouseDown);
                    $window.document.removeEventListener('touchmove', sv.touchMove);
                    $window.document.removeEventListener('mousemove', sv.mousemove);


                    sv.touchStart = function(e) {
                        e.preventDefault = function() {};
                        originaltouchStart.apply(sv, [e]);
                    };

                    sv.touchMove = function(e) {
                        e.preventDefault = function() {};
                        originaltouchMove.apply(sv, [e]);
                    };

                    sv.mouseDown = function(e) {
                        e.preventDefault = function() {};

                        if (originalmouseDown) {
                            originalmouseDown.apply(sv, [e]);
                        }

                    };


                    sv.mouseMove = function(e) {
                        e.preventDefault = function() {};

                        if (originalmouseMove) {
                            originalmouseMove.apply(sv, [e]);
                        }

                    };

                    container.addEventListener("touchstart", sv.touchStart, false);
                    container.addEventListener("mousedown", sv.mouseDown, false);
                    $window.document.addEventListener("touchmove", sv.touchMove, false);
                    $window.document.addEventListener("mousemove", sv.mouseMove, false);
                });

            };
        }
    }
})();

(function() {
  'use strict';
  angular.module('app')
    .directive('ngEnter', ngEnter);

  ngEnter.$inject = ['$window'];

  function ngEnter($window) {
    return function(scope, element, attrs) {
      element.bind("keydown keypress", function(event) {
        if (event.which === 13) {
          scope.$apply(function() {
            scope.$eval(attrs.ngEnter);
          });
          $window.cordova.plugins.Keyboard.close();

          event.preventDefault();
        }
      });
    };
  }
})();

(function() {
  'use strict';

  angular.module('app')
    .directive('onFinishRender', onFinishRender);

  onFinishRender.$inject = ['$timeout'];

  function onFinishRender($timeout) {
    return {
      restrict: 'A',
      link: link
    };

    function link(scope) {
      if (scope.$last === true) {
        $timeout(function() {
          scope.$broadcast('ngRepeatFinished');
        });
      }
    }
  }
})();

//==========================================================================
//              Style for user selection.
//==========================================================================

(function() {
    'use strict';

    angular.module('app')
        .directive('touch', touch);

    touch.$inject = ['$timeout'];

    function touch($timeout) {
        return {
            restrict: 'A',
            link: link
        };

        function link(scope, element) {
            element.on('click', function() {
                element.addClass('touch');
                $timeout(function() {
                    element.removeClass('touch');
                }, 50);

            });
        }
    }

})();

// Makes width of the view available as JS or directive such as collection repeat
// This makes collection repeat to have dynamic width or height which depends on
//the view width or view height;

// usage:
// Required: IndexModel.vw = INT;
// In index.html, body[vw]
// 1) ion-list>ion-item[collection-repeat="item in items" item-height="vw * 0.20"]
// 2) ANY[vw]
// 3) function controller(IndexModel){
//     console.log(IndexModel.vw);
//    }
(function() {
  'use strict';

  angular.module('app')
    .directive('vw', vw);

  vw.$inject = ['$rootScope', '$window'];

  function vw($rootScope, $window) {
    return {
      link: link
    };

    function link(scope, element) {
      $rootScope.windowWidth = element.prop('offsetWidth');

      $window.addEventListener('resize', function() {
        $rootScope.$apply(function() {
          $rootScope.windowWidth = element.prop('offsetWidth');
        });
      });
    }
  }


})();

(function() {
  'use strict';
  angular.module('app')
    .filter('cloudinary400', cloudinaryFilter.bind(null, 400))
    .filter('cloudinary500', cloudinaryFilter.bind(null, 500));

  function cloudinaryFilter(size) {
    var matching = /upload/;
    return function(input) {
      if (input) {
        var index = input.search(matching);
        return input.substring(0, index) + 'upload/c_scale,w_' + size + '/' + input.substring(input.lastIndexOf('/'));
      } else
        return input;
    };
  }
})();

(function() {
    'use strict';
    angular.module('app')
        .filter('mToKm', mToKm);

    // distance.$inject=[];

    function mToKm() {
        return function(input) {
            if (input >= 1000) {
                return (input / 1000).toFixed(2) + 'km';
            } else {
                return input + 'm';
            }
        };
    }
})();

// Input
// vm.openingHours = [{start: "07:00", end: "20:20"}, ..., {start: "08:00", end: "18:00"} ]

// Usage
// div{vm.openingHours | groupByOpeningHours}

// Output
// ["월~목 07:00 ~ 20:20", "금~토 08:00 ~ 16:00", "일요일 휴무"]

(function() {
  'use strict';

  angular.module('app')
    .filter('groupByOpeningHours', groupByOpeningHours);

  groupByOpeningHours.$inject = ['_'];

  function groupByOpeningHours(_) {
    return filter;

    function filter(openingHours) {
      // append index to object
      openingHours = appendIndexToObj(openingHours);
      // group by same hours
      var grouped = groupByBusinessHours(openingHours);
      // create [{days: [0, 1], start: "08:00", end: "20:00"},...}
      var orderedResultArray = createArrayOfObjWithGroup(grouped);
      // create ["월 ~ 금" 08:00 ~ 03:00", "일요일 휴무"]
      var textArray = _.map(orderedResultArray, function(result) {
        // result = {days:[0,1], start: '', end: ''};
        result.days = _.map(result.days, function(day) {
          var daysKorean = parseDay(day);
          return daysKorean;
        });
        result.days = tildeArrayValuesToText(result.days);
        var apendTime = '';
        if (result.start === result.end) {
          apendTime = '휴무';
        } else {
          apendTime = result.start + ' ~ ' + result.end;
        }
        var texts = result.days + ' ' + apendTime;
        return texts;
      });

      return textArray;
    }


    function appendIndexToObj(openingHours) {
      for (var i = 0; i < openingHours.length; i++) {
        openingHours[i].index = i;
      }
      return openingHours;
    }

    function groupByBusinessHours(openingHours) {
      var grouped = _.groupBy(openingHours, function(hoursObj) {
        var start = hoursObj.start;
        var end = hoursObj.end;
        var groupCategory = start + end;
        return groupCategory;
      });
      return grouped;
    }

    function createArrayOfObjWithGroup(grouped) {
      // grouped = ['1212': [{start:'', end:'', index: 0}, ...]]
      // out = [{days:[0,1], start:'',  end:''}, ...]
      var keys = Object.keys(grouped);

      var resultArray = [];
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var subOpeningHoursArray = grouped[key];

        var daysResult = [];
        for (var j = 0; j < subOpeningHoursArray.length; j++) {
          var openingHourObj = subOpeningHoursArray[j];
          daysResult.push(openingHourObj.index);
        }

        var start = subOpeningHoursArray[0].start;
        var end = subOpeningHoursArray[0].end;

        resultArray.push({
          days: daysResult,
          start: start,
          end: end
        });
      }

      var orderedResultArray = _.sortBy(resultArray, function(obj) {
        var day = obj.days[0];
        if (day === 0) {
          day = 7;
        }
        return day;
      });

      return orderedResultArray;
    }

    function parseDay(day) {
      if (day === 0) {
        return '일';
      } else if (day === 1) {
        return '월';
      } else if (day === 2) {
        return '화';
      } else if (day === 3) {
        return '수';
      } else if (day === 4) {
        return '목';
      } else if (day === 5) {
        return '금';
      } else if (day === 6) {
        return '토';
      }
    }

    function tildeArrayValuesToText(array) {
      var daysInNumbers = _.map(array, function(dayInKorean) {
        if (dayInKorean === '일') {
          return 7;
        } else if (dayInKorean === '월') {
          return 1;
        } else if (dayInKorean === '화') {
          return 2;
        } else if (dayInKorean === '수') {
          return 3;
        } else if (dayInKorean === '목') {
          return 4;
        } else if (dayInKorean === '금') {
          return 5;
        } else if (dayInKorean === '토') {
          return 6;
        }
      });
      for (var i = 0; i < daysInNumbers.length - 1; i++) {
        var day_1 = daysInNumbers[i];
        var day_2 = daysInNumbers[i + 1];
        if (Math.abs(day_1 - day_2) > 1) {
          var concatStart = array[0];
          for (var j = 1; j < daysInNumbers.length; j++) {
            concatStart = concatStart + ', ' + array[j];
          }
          return concatStart;
        }
      }
      if (array.length > 2) {
        return array[0] + ' ~ ' + array[array.length - 1];
      } else if (array.length === 2) {
        return array[0] + ', ' + array[1];
      } else if (array.length === 1) {
        return array[0];
      }
    }
  }

})();

(function() {
    'use strict';
    angular.module('app')
        .filter('filterByTag', filterByTag);

    // filterByTag.$inject = [];
    function filterByTag() {

        return filter;

        function filter(collection, tagName) {
            var resultArray = [];
            if (collection) {

                for (var i = 0; i < collection.length; i++) {
                    var element = collection[i];
                    for (var j = 0; j < element.tags.length; j++) {
                        var tag = element.tags[j];
                        if (tag === tagName) {
                            resultArray.push(element);
                        }
                    }
                }
            }
            return resultArray;
        }
    }


})();

(function() {
    'use strict';

    angular.module('app')
        .factory('Bookings', Bookings);

    Bookings.$inject = ['$resource', 'governorUrl', '$cordovaFileTransfer'];

    function Bookings($resource, governorUrl, $cordovaFileTransfer) {

        var bookingUrl = governorUrl + '/booking' + '/:list' +
            '/:image' + '/:mine' + '/:dateBetween' + '/:request';

        var params = {
            list: '@list',
            image: '@image',
            mine: '@mine',
            dateBetween: '@dateBetween'
        };

        var actions = {
            getBookings: {
                method: 'GET',
                params: {
                    list: 'list'
                }
            },
            getMyBookings: {
                method: 'GET',
                params: {
                    list: 'list',
                    mine: 'mine'
                }
            },
            getBookingsDateBetween: {
                method: 'GET',
                params: {
                    dateBetween: 'dateBetween'
                }
            },

            findById: {
                method: 'GET'
            },

            createBooking: {
                method: 'POST'
            },

            requestBooking: {
                method: 'POST',
                params: {
                    request: 'request'
                }
            },
            updateBooking: {
                method: 'PUT',
                isArray: true,
                headers: {
                    'Content-Type': 'text/plain'
                }
            },
            removeBooking: {
                method: 'DELETE'
            }
        };

        var service = $resource(bookingUrl, params, actions);

        //------------------------
        //  CUSTOM NON-HTTP METHODS
        //------------------------
        service.createBookingWithImage = function(parameters, booking) {
            angular.extend(booking, parameters);
            var filePath = booking.file;
            delete booking.file;
            var options = {
                params: booking,
                chunkedMode: false
            };
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/booking/image', filePath, options)
            };
        };

        service.updateBookingWithImage = function(parameters, booking) {
            angular.extend(booking, parameters);
            var filePath = booking.file;
            delete booking.file;
            var options = {
                params: booking,
                chunkedMode: false,
                httpMethod: 'PUT'
            };
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/booking/image', filePath, options)
            };

        };

        return service;
    }

    // Booking.get({
    //     list: 'list',
    //     category: 'SHOW-POST'
    // }).$promise
    //     .then(function success() {}, function err() {})

    // Bookings.createBookingWithImage({}, bookingWithFile).$promise
    //     .then(function success() {}, function error() {}, function progress(progress) {})

    // require id in bookingWithFile sails' req.param('id') not only look at url params but
    //also looks at the body of req, it is a sails spcific feature.
    // Bookings.createBookingWithImage({}, bookingWithFile).$promise
    //     .then(function success() {}, function error() {}, function progress(progress) {})

})();

(function() {
    'use strict';

    angular.module('app')
        .factory('Comments', Comments);

    Comments.$inject = ['$resource', 'governorUrl'];

    function Comments($resource, governorUrl) {

        var commentUrl = governorUrl + '/post/comment';

        var params = {};

        var actions = {
            addCommentToPost: {
                method: 'POST'
            }
        };

        var service = $resource(commentUrl, params, actions);

        return service;
    }

})();

// TODO: remove pushservice and implement own device/push logic
(function() {
    'use strict';

    angular.module('app')
        .factory('Contacts', Contacts);

    Contacts.$inject = ['$resource', 'governorUrl'];

    function Contacts($resource, governorUrl) {

        var deviceUrl = governorUrl + '/:contact' + '/:admin';

        var params = {
            'contact': '@contact',
            'admin': '@admin'
        };

        var actions = {
            contactAdmin: {
                method: 'POST',
                params: {
                    contact: 'contact',
                    admin: 'admin'
                }
            }
        };

        var service = $resource(deviceUrl, params, actions);

        return service;
    }
})();

// TODO: remove pushservice and implement own device/push logic
(function() {
    'use strict';

    angular.module('app')
        .factory('Devices', Devices);

    Devices.$inject = ['$resource', 'governorUrl', 'PushService'];

    function Devices($resource, governorUrl, PushService) {

        var deviceUrl = governorUrl + '/device' + '/:sendMessageAll';

        var params = {
            sendMessageAll: '@sendMessageAll'
        };

        var actions = {
            pushAll: {
                method: 'GET',
                params: {
                    sendMessageAll: 'sendMessageAll'
                }
            },

            register: {
                method: 'POST',
            },

            update: {
                method: 'PUT'
            }
        };

        var service = $resource(deviceUrl, params, actions);

        service.getDeviceIdSync = function() {
            var deviceId = PushService.getDeviceId();
            return deviceId;
        };

        return service;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('Likes', Likes);

    Likes.$inject = ['$resource', 'governorUrl'];

    function Likes($resource, governorUrl) {

        var likesUrl = governorUrl + '/post' + '/:like' + '/:unlike';

        var params = {
            like: '@like',
            unlike: '@unlike'
        };
        var actions = {
            likePost: {
                method: 'POST'
            },
            unlikePost: {
                method: 'DELETE'
            }
        };

        var service = $resource(likesUrl, params, actions);

        return service;
    }

})();

(function() {
    'use strict';

    angular.module('app')
        .factory('Photos', Photos);

    Photos.$inject = ['$resource', 'governorUrl', 'AuthService', '$cordovaFileTransfer'];

    function Photos($resource, governorUrl, AuthService, $cordovaFileTransfer) {

        var photosUrl = governorUrl + '/photo';

        var params = {};

        var actions = {
            removePhoto: {
                method: 'DELETE'
            }
        };

        var service = $resource(photosUrl, params, actions);

        service.uploadPhoto = function(parameters, post) {
            angular.extend(post, parameters);
            var filePath = post.file ? post.file : '[]';
            delete post.file;
            var options = {
                params: post,
                chunkedMode: false,
                headers: {
                    Connection: "close",
                    Authorization: 'Bearer ' + AuthService.getToken()
                }
            };
            console.log(post);
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/photo', filePath, options, true)
            };
        };

        return service;
    }

})();

(function() {
    'use strict';

    angular.module('app')
        .factory('Places', Places);

    Places.$inject = ['$resource', 'governorUrl', '$cordovaFileTransfer'];

    function Places($resource, governorUrl, $cordovaFileTransfer) {

        var placeUrl = governorUrl + '/place' + '/:list' + '/:mine' +
            '/:within' + '/:image' + ':photos';

        var params = {
            list: '@list',
            mine: '@mine',
            within: '@within',
            image: '@image',
            photos: '@photos'
        };

        var actions = {
            getPlaces: {
                method: 'GET',
                params: {
                    list: 'list'
                }
            },
            getMyPlaces: {
                method: 'GET',
                params: {
                    list: 'list',
                    mine: 'mine'
                }
            },
            getPlacesWithin: {
                method: 'GET',
                params: {
                    list: 'list',
                    within: 'within'
                }
            },
            getPlacePhotos: {
                method: 'GET',
                params: {
                    photos: 'photos'
                },
                isArray: true
            },
            findById: {
                method: 'GET'
            },
            createPlace: {
                method: 'POST'
            },
            createPlaceWithImage: {
                method: 'POST',
                params: {
                    image: 'image'
                }
            },
            updatePlace: {
                method: 'PUT',
                isArray: true

            },
            updateMyPlace: {
                method: 'PUT',
                params: {
                    mine: 'mine'
                },
                isArray: true
            },
            updatePlaceWithImage: {
                method: 'PUT',
                params: {
                    image: 'image'
                }
            },
            removePlace: {
                method: 'DELETE'
            }
        };

        var service = $resource(placeUrl, params, actions);

        //------------------------
        //  CUSTOM NON-HTTP METHODS
        //------------------------
        service.createPlaceWithImage = function(parameters, place) {
            angular.extend(place, parameters);
            var filePath = place.file;
            delete place.file;
            var options = {
                params: place,
                chunkedMode: false
            };
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/place/image', filePath, options)
            };
        };

        service.updatePlaceWithImage = function(parameters, place) {
            angular.extend(place, parameters);
            var filePath = place.file;
            delete place.file;
            var options = {
                params: place,
                chunkedMode: false,
                httpMethod: 'PUT'
            };
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/place/image', filePath, options)
            };

        };
        return service;
    }

})();

(function() {
    'use strict';
    angular.module('app')
        .factory('Posts', Posts);

    Posts.$inject = ['$resource', 'governorUrl', '$cordovaFileTransfer', 'AuthService'];

    function Posts($resource, governorUrl, $cordovaFileTransfer, AuthService) {

        var postUrl = governorUrl + '/post' + '/:list' +
            '/:image' + '/:mine' + '/:like';

        var params = {
            list: '@list',
            image: '@image',
            mine: '@mine',
            like: '@like'
        };

        var actions = {
            getPosts: {
                method: 'GET',
                params: {
                    list: 'list'
                }
            },
            getMyPosts: {
                method: 'GET',
                params: {
                    list: 'list',
                    mine: 'mine'
                }
            },
            findById: {
                method: 'GET'
            },
            createPost: {
                method: 'POST'
            },
            updatePost: {
                method: 'PUT'
            },
            likePost: {
                method: 'POST',
                params: {
                    like: 'like'
                }
            },
            removePost: {
                method: 'DELETE'
            }
        };

        var service = $resource(postUrl, params, actions);

        //------------------------
        //  CUSTOM NON-HTTP METHODS
        //------------------------
        service.createPostWithImage = function(parameters, post) {
            angular.extend(post, parameters);
            var filePath = post.file ? post.file : '[]';
            delete post.file;
            post.category = "SHOW-POST";
            var options = {
                params: post,
                chunkedMode: false,
                headers: {
                    Connection: "close",
                    Authorization: 'Bearer ' + AuthService.getToken()
                }
            };
            console.log(post);
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/post', filePath, options, true)
            };
        };

        service.updatePostWithImage = function(parameters, post) {
            angular.extend(post, parameters);
            var filePath = post.file;
            delete post.file;
            var options = {
                params: post,
                chunkedMode: false,
                httpMethod: 'PUT',
                headers: {
                    Connection: "close",
                    Authorization: 'Bearer ' + AuthService.getToken()
                }
            };
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/post', filePath, options, true)
            };

        };

        return service;
    }

    // Post.get({
    //     list: 'list',
    //     category: 'SHOW-POST'
    // }).$promise
    //     .then(function success() {}, function err() {})

    // Posts.createPostWithImage({}, postWithFile).$promise
    //     .then(function success() {}, function error() {}, function progress(progress) {})

    // require id in postWithFile sails' req.param('id') not only look at url params but
    //also looks at the body of req, it is a sails spcific feature.
    // Posts.createPostWithImage({}, postWithFile).$promise
    //     .then(function success() {}, function error() {}, function progress(progress) {})


})();

(function() {
    'use strict';
    angular.module('app')
        .factory('Products', Products);

    Products.$inject = ['$resource', 'governorUrl', '$cordovaFileTransfer'];

    function Products($resource, governorUrl, $cordovaFileTransfer) {

        var productUrl = governorUrl + '/product' + '/:list' +
            '/:image' + '/:mine' + '/:checkProductCode';

        var params = {
            list: '@list',
            image: '@image',
            mine: '@mine',
            checkProductCode: '@checkProductCode'
        };

        var actions = {
            getProducts: {
                method: 'GET',
                params: {
                    list: 'list'
                }
            },
            getMyProducts: {
                method: 'GET',
                params: {
                    list: 'list',
                    mine: 'mine'
                }
            },
            checkProductCode: {
                method: 'GET',
                params: {
                    checkProductCode: 'checkProductCode'
                }
            },
            findById: {
                method: 'GET'
            },
            createProduct: {
                method: 'POST'
            },
            updateProduct: {
                method: 'PUT'
            },
            removeProduct: {
                method: 'DELETE'
            }
        };

        var service = $resource(productUrl, params, actions);

        //------------------------
        //  CUSTOM NON-HTTP METHODS
        //------------------------
        service.createProductWithImage = function(parameters, product) {
            angular.extend(product, parameters);
            var filePath = product.file;
            delete product.file;
            var options = {
                params: product,
                chunkedMode: false
            };
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/product/image', filePath, options)
            };
        };

        service.updateProductWithImage = function(parameters, product) {
            angular.extend(product, parameters);
            var filePath = product.file;
            delete product.file;
            var options = {
                params: product,
                chunkedMode: false,
                httpMethod: 'PUT'
            };
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/product/image', filePath, options)
            };

        };

        return service;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('RoyaltyPoints', RoyaltyPoints);

    RoyaltyPoints.$inject = ['$resource', 'governorUrl'];

    function RoyaltyPoints($resource, governorUrl) {

        var royaltyUrl = governorUrl + '/royaltyPoint' + '/:list' + '/:mine';

        var params = {
            list: '@list',
            mine: '@mine'
        };

        var actions = {
            getRoyaltyPoints: {
                method: 'GET',
                params: {
                    list: 'list'
                }
            },

            getMyRoyaltyPoints: {
                method: 'GET',
                params: {
                    list: 'list',
                    mine: 'mine'
                }
            },

            findById: {
                method: 'GET'
            },

            createRoyaltyPoint: {
                method: 'POST',
            },

            updateRoyaltyPoint: {
                method: 'PUT',
                isArray: true
            },

            removeRoyaltyPoint: {
                method: 'DELETE'
            }
        };

        var service = $resource(royaltyUrl, params, actions);

        return service;
    }

})();

(function() {
    'use strict';

    angular.module('app')
        .factory('Users', Users);


    Users.$inject = ['$resource', 'governorUrl'];

    function Users($resource, governorUrl) {

        var userUrl = governorUrl + '/:auth' + '/:register' + '/:user' + '/:local' +
            '/:checkNickname' + '/:list' + '/:role' + '/:myrole';

        var params = {
            auth: '@auth',
            register: '@register',
            user: '@user',
            checkNickname: '@checkNickname',
            list: '@list',
            role: '@role'
        };

        var actions = {
            register: {
                method: 'POST',
                params: {
                    register: 'register'
                }
            },
            checkNickname: {
                method: 'GET',
                params: {
                    user: 'user',
                    checkNickname: 'checkNickname'
                }
            },
            login: {
                method: 'POST',
                params: {
                    auth: 'auth',
                    local: 'local'
                }
            },
            getMyRole: {
                method: 'GET',
                params: {
                    role: 'role',
                    myrole: 'myrole'
                }
            }
        };

        var service = $resource(userUrl, params, actions);

        return service;
    }
})();

(function() {
  'use strict';
  angular.module('app')
    .controller('AdminController', AdminController);

  AdminController.$inject = ['AdminModel', 'Places', '$scope', 'Message', 'appStorage', '$state'];

  function AdminController(AdminModel, Places, $scope, Message, appStorage, $state) {

    var Admin = this;
    Admin.Model = AdminModel;
    Admin.updateTableSexPercentage = updateTableSexPercentage;
    Admin.updatePopularMenu = updatePopularMenu;

    $scope.$on('$ionicView.beforeEnter', onBeforeEnter);

    //------------------------
    //  IMPLEMENTATIONS
    //------------------------

    function onBeforeEnter() {
      Message.loading();
      Places.getMyPlaces({
        id: appStorage.user.id
      }).$promise
        .then(function success(placesWrapper) {
          console.log('---------- placesWrapper ----------');
          console.log(placesWrapper);
          console.log('HAS TYPE: ' + typeof placesWrapper);
          console.log('---------- CONSOLE END -------------------');

          AdminModel.place = placesWrapper.places[0];
          Message.hide();
        }, function err(error) {
          console.log(error);
          Message.hide();
          Message.alert('관리자 알림', '현재가지고 있으신 바가 없습니다.');
        });
    }

    function updateTableSexPercentage() {
      Places.updateMyPlace({
        id: AdminModel.place.id
      }, {
        male: AdminModel.form.male,
        female: AdminModel.form.female
      }).$promise
        .then(function success(data) {
          Message.hide();
          AdminModel.form.male = '';
          AdminModel.form.female = '';
          Message.alert('실시간정보 알림', '테이블 현황이 업데이트 되었습니다.');
          console.log('---------- data ----------');
          console.log(data);
          console.log('HAS TYPE: ' + typeof data);
          console.log('---------- CONSOLE END -------------------');

        }, function err(error) {
          Message.hide();
          Message.alert();
          console.log('---------- error ----------');
          console.log(error);
          console.log('HAS TYPE: ' + typeof error);
          console.log('---------- CONSOLE END -------------------');

        });

    }

    function updatePopularMenu() {
      Places.updateMyPlace({
        id: AdminModel.place.id
      }, {
        popularFood: AdminModel.form.popularFood,
        popularDrink: AdminModel.form.popularDrink
      }).$promise
        .then(function success(data) {
          Message.hide();
          Message.alert('실시간정보 알림', '인기 안주와 인기 주류가 업데이트 되었습니다.')
            .then(function() {
              $state.go('main.home.theme');
            });
          // AdminModel.form.popularFood = [{
          //     name: '',
          //     percentage: ''
          // }, {
          //     name: '',
          //     percentage: ''
          // }, {
          //     name: '',
          //     percentage: ''
          // }];
          // AdminModel.form.popularDrink = [{
          //     name: '',
          //     percentage: ''
          // }, {
          //     name: '',
          //     percentage: ''
          // }, {
          //     name: '',
          //     percentage: ''
          // }];
          console.log('---------- data ----------');
          console.log(data);
          console.log('HAS TYPE: ' + typeof data);
          console.log('---------- CONSOLE END -------------------');

        }, function err(error) {
          Message.hide();
          Message.alert();
          console.log('---------- error ----------');
          console.log(error);
          console.log('HAS TYPE: ' + typeof error);
          console.log('---------- CONSOLE END -------------------');

        });


    }
  }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('AdminModel', AdminModel);

    AdminModel.$inject = [];

    function AdminModel() {

        var model = {
            place: {},
            form: {
                male: '',
                female: '',
                popularFood: [{
                    name: null,
                    percentage: null
                }, {
                    name: null,
                    percentage: null
                }, {
                    name: null,
                    percentage: null
                }],
                popularDrink: [{
                    name: null,
                    percentage: null
                }, {
                    name: null,
                    percentage: null
                }, {
                    name: null,
                    percentage: null
                }]
            }
        };
        return model;
    }
})();

(function() {
    'use strict';
    angular.module('app')
        .controller('AdminMenuController', AdminMenuController);

    AdminMenuController.$inject = ['AdminMenuModel', 'Places', '$scope'];

    function AdminMenuController(AdminMenuModel, Places, $scope) {

        var AdminMenu = this;
        AdminMenu.Model = AdminMenuModel;

        $scope.$on('$ionicView.beforeEnter', onBeforeEnter);

        //------------------------
        //  IMPLEMENTATIONS
        //------------------------

        function onBeforeEnter() {
            Places.getMyPlaces({}).$promise
                .then(function success(data) {
                    console.log('---------- data ----------');
                    console.log(data);
                    console.log('HAS TYPE: ' + typeof data);
                    console.log('---------- CONSOLE END -------------------');

                }, function err(error) {
                    console.log('---------- error ----------');
                    console.log(error);
                    console.log('HAS TYPE: ' + typeof error);
                    console.log('---------- CONSOLE END -------------------');
                });
        }
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('AdminMenuModel', AdminMenuModel);

    AdminMenuModel.$inject = [];

    function AdminMenuModel() {

        var model = {

        };
        return model;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .controller('DaumMapController', DaumMapController);

    DaumMapController.$inject = ['DaumMapModel', '$ionicModal', '$scope', '$state', '$stateParams', '$timeout'];

    function DaumMapController(DaumMapModel, $ionicModal, $scope, $state, $stateParams, $timeout) {

        var Map = this;
        Map.Model = DaumMapModel;

        Map.searchType = "address";



        Map.findMeThenSearchNearBy = DaumMapModel.findMeThenSearchNearBy;

        Map.searchLocationNearBy = function(value) {

            if (Map.searchType === 'address') {
                return DaumMapModel.searchLocationNearBy(value);
            } else if (Map.searchType === 'placeName') {
                return DaumMapModel.searchPlaceByName(value);
            }
        };

        Map.setPlaceholderText = function() {
            if (Map.searchType === 'address') {
                return '지역을 검색해주세요';
            } else if (Map.searchType === 'placeName') {
                return '상호명을 입력해주세요';
            }
        };

        Map.goToDetailHandler = function(state) {
            DaumMapModel.modal.hide();
            $state.go(state, {
                id: DaumMapModel.selectedPlace.id
            });
        };
        Map.goToHandler = function(state, params) {
            $state.go(state, params);
        };
        Map.hasStateParams = function(paramName) {
            return !!$stateParams[paramName];
        };


        // Make currently selected place from DaumMapDirective available at ModalView
        Map.selectedPlace = DaumMapModel.selectedPlace;

        $scope.$on('$ionicView.enter', function() {
            // Set Modal
            $ionicModal.fromTemplateUrl('state/daumMap/placeModal.html', {
                scope: $scope,
                animation: 'slide-in-up'
            })
                .then(function(modal) {
                    DaumMapModel.modal = modal;
                });
            DaumMapModel.domMap.relayout();
            if ($stateParams.id) {
                DaumMapModel.findPlaceByIdThenDrawAPlace($stateParams.id);
            }
        });
        $scope.$on('$ionicView.afterEnter', function() {
            $timeout(function() {
                DaumMapModel.domMap.relayout();
            }, 0);
        });

    }
})();

(function() {
  'use strict';

  angular.module('app')
    .directive('daumMap', daumMap);

  daumMap.$inject = ['DaumMapModel', 'Places', 'Bookings', '$state', '$cordovaGeolocation', 'Message', '$q',
    '$stateParams', 'daum', '_', 'moment'
  ];

  function daumMap(DaumMapModel, Places, Bookings, $state, $cordovaGeolocation, Message, $q, $stateParams, daum, _, moment) {
    return {
      scope: {
        markerSrc: '@',
        markerClickedSrc: '@',
        markerWidth: '@',
        markerHeight: '@',
      },
      compile: function(element) {
        //==========================================================================
        //              Global Map Property
        //==========================================================================
        // Initiate map
        var interval = 30;
        var DOM = element[0];
        var mapOptions = {
          center: new daum.maps.LatLng(37.5, 127),
          level: 4,
          draggable: true
        };
        daum.maps.disableHD();
        var map = new daum.maps.Map(DOM, mapOptions);
        // place service
        var ps = new daum.maps.services.Places();

        var filterValue = null;
        // ==========================================================================
        //              HELPER FUNCTIONS
        // ==========================================================================
        // filter query
        function filterPlaces(places, rangeMinutes) {

          var currentMoment = setCurrentMoment();

          var arrayOfIds = _.pluck(places, 'id');

          var arrayOfPromises = _.map(arrayOfIds, function(id) {
            return Bookings.getBookingsDateBetween({
              placeId: id,
              from: currentMoment.clone().set({
                hour: 0,
                minute: 0,
                second: 0
              }).toDate().getTime(),
              to: currentMoment.clone().set({
                hour: 23,
                minute: 59,
                second: 59
              }).toDate().getTime()
            }).$promise;
          });

          return $q.all(arrayOfPromises)
            .then(function success(arrayOfBookingsWrapper) {

              var availabilities = checkAvailableSlots(places, arrayOfBookingsWrapper, interval, currentMoment, rangeMinutes);

              if (availabilities.length === 0) {
                return [];
              }
              for (var i = places.length - 1; i >= 0; i--) {
                if (availabilities[i] === 'unavailable') {
                  places.splice(i, 1);
                }
              }

              return places;

            }, function err(arrayOfErrors) {
              console.log(arrayOfErrors);
            });
        }

        function setCurrentMoment() {
          var currentMinute = moment().get('minute');
          var currentMoment = null;
          if (currentMinute <= 30) {
            currentMoment = moment().set({
              minutes: 29
            });
          } else {
            currentMoment = moment().set({
              minutes: 59
            });
          }
          return currentMoment;
        }

        function checkAvailableSlots(places, arrayOfBookingsWrapper, interval, currentMoment, rangeMinutes) {
          var todayInt = currentMoment.clone().get('day');

          var closingMomentsForToday = [];
          angular.forEach(places, function(place, i) {
            console.log(place);
            var endHourArray = place.openingHours[todayInt].end.split(':');
            var hours = endHourArray[0];
            var minutes = endHourArray[1];
            var closingMoment = moment().set({
              hour: hours,
              minutes: minutes
            });
            if (place.openingHours[todayInt].start === place.openingHours[todayInt].end) {
              places.splice(i, 1, null);
              arrayOfBookingsWrapper.splice(i, 1, null);
            } else if (currentMoment.isAfter(closingMoment)) {
              places.splice(i, 1, null);
              arrayOfBookingsWrapper.splice(i, 1, null);
            } else {
              closingMomentsForToday.push(closingMoment);
            }
          });
          var i = 0;
          for (i = places.length - 1; i >= 0; i--) {
            if (places[i] === null) {
              places.splice(i, 1);
              arrayOfBookingsWrapper.splice(i, 1);
            }
          }
          if (places.length === 0) {
            Message.alert('바로검색 알림', '현재 시각 주변에 운영하는 네일샵들이 없습니다. 내일 이용해주시거나, 다른 지역을 검색해주세요.');
            return [];
          }


          var arrayOfBookings = _.map(arrayOfBookingsWrapper, function(bookingsWrapper) {
            return bookingsWrapper.bookings;
          });
          console.log('arrayOfBookings');
          console.log(arrayOfBookings);
          var arrayOfDurations = _.map(arrayOfBookings, function(bookings) {
            return _.map(bookings, function(booking) {
              return booking.products[0].product.duration;
            });
          });
          var arrayOfBookingsMoment = []; // [ [newbooking, newbooking,... ], []]
          for (i = 0; i < arrayOfDurations.length; i++) {
            var resultArray_i = []; // inner [] of resultArray = [ [], [], ... ]
            var bookings = arrayOfBookings[i];
            var durations = arrayOfDurations[i];
            var place = places[i];
            console.log('place');
            console.log(place);
            for (var j = 0; j < durations.length; j++) {
              var booking = bookings[i];
              var datetime = booking.datetime;
              var bookingMoment = moment(datetime);
              var duration = durations[i];
              var closingMoment = closingMomentsForToday[i];
              if (bookingMoment.isBetween(currentMoment.clone(), currentMoment.clone().add(rangeMinutes, 'minutes')) &&
                bookingMoment.isBefore(closingMoment.clone())) {
                resultArray_i.push(bookingMoment);
              }
              var slotsTaken = Math.ceil(duration / interval);
              for (var k = 0; k < slotsTaken; k++) {
                var minutesToAdd = interval * (k + 1);
                var trailingBookingMoment = bookingMoment.clone().add(minutesToAdd, 'minutes');
                if (trailingBookingMoment.isBetween(currentMoment.clone(), currentMoment.clone().add(rangeMinutes, 'minutes')) &&
                  trailingBookingMoment.isBefore(closingMoment.clone())) {
                  resultArray_i.push(trailingBookingMoment);
                }
              }
            }
            arrayOfBookingsMoment.push(resultArray_i);
          }
          console.log('arrayOfBookingsMoment');
          console.log(arrayOfBookingsMoment);


          var arrayOfTimeStrings = [];

          function generateTimeStrings(bookingMoment) {
            var hours = bookingMoment.get('hours');
            var minutes = bookingMoment.get('minutes');
            var timeString = String(hours) + ':' + String(minutes);
            return timeString;
          }

          for (i = 0; i < arrayOfBookingsMoment.length; i++) {
            var bookingsMoment = arrayOfBookingsMoment[i];
            console.log(bookingsMoment);
            var timeStrings = _.map(bookingsMoment, generateTimeStrings);
            if (timeStrings.length === 0) {
              timeStrings = ['available'];
            }
            arrayOfTimeStrings.push(timeStrings);
          }
          console.log('arrayOfTimeStrings');
          console.log(arrayOfTimeStrings);

          var arrayOfGroupedTimeStrings = [];
          angular.forEach(arrayOfTimeStrings, function(timeStrings) {
            var groupedTimeStrings = _.groupBy(timeStrings, function(timeString) {
              return timeString;
            });
            arrayOfGroupedTimeStrings.push(groupedTimeStrings);
          });
          console.log('arrayOfGroupedTimeStrings');
          console.log(arrayOfGroupedTimeStrings);

          var availabilities = [];
          for (i = 0; i < arrayOfGroupedTimeStrings.length; i++) {
            var availabilityFlag = false;
            var place_i = places[i];
            for (var key in arrayOfGroupedTimeStrings[i]) {
              if (arrayOfGroupedTimeStrings[i][key].length < place_i.employee || key === 'available') {
                availabilities.push('available');
                availabilityFlag = true;
                break;
              }
            }
            if (availabilityFlag === false) {
              availabilities.push('unavailable');
            }
          }
          console.log('availabilities');
          console.log(availabilities);
          return availabilities;
        }

        function processPin(markerImg, markerClickedImg, scope) {

          angular.forEach(DaumMapModel.places, function(place, i) {
            //place = {location:{type:'Point', coordinates:[126.10101, 27.101010]}, ...}
            var placeLongitude = place.location.coordinates[0];
            var placeLatitude = place.location.coordinates[1];
            // set marker
            var position = new daum.maps.LatLng(placeLatitude, placeLongitude);
            var marker = new daum.maps.Marker({
              map: map,
              position: position,
              // used as to link to place info
              title: String(i),
              image: markerImg,
              clickable: true
            });
            daum.maps.event.addListener(marker, 'click', function() {
              var marker = this;
              scope.$apply(function() {
                // on click: differentiate clicked image;
                angular.forEach(DaumMapModel.markers, function(otherMarker) {
                  otherMarker.setImage(markerImg);
                });
                marker.setImage(markerClickedImg);
                // on click: show modal which will be filled with place info
                // modal references DaumMapModel.selectedPlace to fill in the info
                var index = Number(marker.getTitle());
                Message.loading();

                Places.findById({
                  id: DaumMapModel.places[index].id,
                  populates: 'photos'
                }).$promise
                  .then(function success(data) {
                    Message.hide();
                    DaumMapModel.selectedPlace = data;
                    console.log(DaumMapModel.selectedPlace);
                    DaumMapModel.modal.show();
                  }, function err(error) {
                    console.log(error);
                    Message.hide();
                    Message.alert();

                  });
                // DaumMapModel.selectedPlace = DaumMapModel.places[index];
              });
            });
            // Save converted place with click event added.
            DaumMapModel.markers.push(marker);
          });
        }

        // Draw Markers after query
        var drawMarkers = function(currentCenter, markerImg, markerClickedImg, scope) {
          // Reset previous markers;
          angular.forEach(DaumMapModel.markers, function(marker) {
            marker.setMap(null);
          });
          DaumMapModel.markers = [];


          // Request server for places;
          var PlacesPromise = {};
          if ($stateParams.id) {
            PlacesPromise = Places.findById({
              id: $stateParams.id,
              populates: 'photos'
            }).$promise;
          } else {
            PlacesPromise = Places.getPlacesWithin({
              latitude: currentCenter.latitude,
              longitude: currentCenter.longitude,
              distance: currentCenter.distance || 5000,
              limit: currentCenter.limit || 50,
              filter: filterValue || null,
            }).$promise;
          }
          PlacesPromise
            .then(function success(placesWrapper) {

              if ($stateParams.id) {
                DaumMapModel.places = [placesWrapper];
              } else {
                DaumMapModel.places = placesWrapper.places;
              }
              processPin(markerImg, markerClickedImg, scope);
              Message.hide();
              filterValue = null;

            }, function error(err) {
              console.log(err);
              filterValue = null;
            });
        };

        //==========================================================================
        //              Find Current location and search nearby
        //==========================================================================
        DaumMapModel.findMeThenSearchNearBy = function(justFind) {
          Message.loading();
          // filterValue = null;
          $cordovaGeolocation.getCurrentPosition({
            maximumAge: 600000,
            timeout: 5000
          })
            .then(function success(position) {
              Message.hide();
              if (position.coords == null) {
                Message.hide();
                Message.alert(
                  '위치 공유가 꺼져있습니다.',
                  '위치 공유를 켜주세요.'
                );
                return false;
              }

              DaumMapModel.currentPosition = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude
              };

              if (!justFind) {
                map.setCenter(new daum.maps.LatLng(
                  DaumMapModel.currentPosition.latitude,
                  DaumMapModel.currentPosition.longitude
                ));
              }

              // No longer needed as when map's center is moved it will draw.
              // drawMarkers(currentCenter);
            }, function error(err) {
              Message.alert(
                '위치 공유가 꺼져있습니다.',
                '위치 공유를 켜주세요.'
              );
              console.log('---------- err ----------');
              console.log(err);
              console.log('HAS TYPE: ' + typeof err);
              console.log('---------- CONSOLE END -------------------');

              Message.hide();
            });
          Message.hide();
        };
        //==========================================================================
        //              Find specific location with value and search nearby
        //==========================================================================
        DaumMapModel.searchLocationNearBy = function(value) {
          Message.loading();
          if (!value) {
            Message.hide();
            Message.alert('검색하기 알림', '장소 값을 넣어서 다시 검색해주세요');
            return false;
          }
          // filterValue = null;
          ps.keywordSearch(value, function(status, data) {

            // if no search result, notify and exit.
            if (data.places[0] === undefined) {
              Message.hide();
              Message.alert(
                '요청하신 장소가 없습니다',
                '다시검색해주세요'
              );
              return false;
            }
            console.log(status);

            // move to center of searched result.
            map.panTo(new daum.maps.LatLng(
              data.places[0].latitude,
              data.places[0].longitude
            ));

            // No longer needed as when map's center is moved it will draw.
            // drawMarkers(currentCenter);

            Message.hide();
          }, function(err) {
            console.log(err);
            console.log(err);
            Message.hide();
            Message.alert({
              title: '위치 공유가 꺼져있습니다.',
              template: '위치 공유 켜주세요.'
            });
          });
        };


        //------------------------
        //  Instead of querying Daum query our server and pane to that location.
        //------------------------
        DaumMapModel.searchPlaceByName = function(value) {

          Message.loading();

          if (!value) {
            Message.hide();
            Message.alert('검색하기 알림', '장소 값을 넣어서 다시 검색해주세요');
            return false;
          }
          filterValue = value;

          // Request server for places;
          Places.getPlaces({
            category: 'HUNGERS-BAR',
            filter: value,
            limit: 50
          }).$promise
            .then(function success(placesWrapper) {


              if (placesWrapper.places && placesWrapper.places.length > 0) {
                map.panTo(new daum.maps.LatLng(
                  placesWrapper.places[0].location.coordinates[1],
                  placesWrapper.places[0].location.coordinates[0]
                ));

              } else {
                Message.hide();
                Message.alert(
                  '요청하신 장소가 없습니다',
                  '다시검색해주세요'
                );
                return false;
              }

              Message.hide();

            }, function error(err) {
              console.log(err);
            });
        };


        //------------------------
        //  Find a place with id and pane to that location.
        //------------------------
        DaumMapModel.findPlaceByIdThenDrawAPlace = function(id) {
          Message.loading();
          Places.findById({
            id: id,
            populates: 'photos'
          }).$promise
            .then(function success(place) {
              console.log('---------- place ----------');
              console.log(place);
              console.log('HAS TYPE: ' + typeof place);
              console.log('---------- CONSOLE END -------------------');
              //-------------------------------------------------------
              //  Hacky fix: when coming back to map if the map's center is the same as the
              // place we want to pane to, search does not get called. So make it wiggle a bit.
              //-------------------------------------------------------
              var currentCenter = {
                longitude: map.getCenter().getLng(),
                latitude: map.getCenter().getLat()
              };
              if (Math.abs(currentCenter.longitude - place.location.coordinates[1]) < 0.00001 &&
                Math.abs(currentCenter.latitude - place.location.coordinates[0]) < 0.00001
              ) {
                map.panTo(new daum.maps.LatLng(
                  currentCenter.longitude + 0.011,
                  currentCenter.latitude + 0.011
                ));
                // map.panTo(new daum.maps.LatLng(
                //     currentCenter.longitude - 0.011,
                //     currentCenter.latitude - 0.011
                // ));
              }
              //------------------------
              //  Hacky fix ends;
              //------------------------
              map.panTo(new daum.maps.LatLng(
                place.location.coordinates[1],
                place.location.coordinates[0]
              ));
              Message.hide();
            }, function err(error) {
              console.log('---------- error ----------');
              console.log(error);
              console.log('HAS TYPE: ' + typeof error);
              console.log('---------- CONSOLE END -------------------');
            });
        };


        return function(scope) {
          // Marker style properties.
          var markerSize = new daum.maps.Size(Number(scope.markerWidth), Number(scope.markerHeight));
          var markerImg = new daum.maps.MarkerImage(scope.markerSrc, markerSize);
          var markerClickedImg = new daum.maps.MarkerImage(scope.markerClickedSrc, markerSize);
          map.relayout();
          DaumMapModel.domMap = map;
          // ------------------------
          //  Search when moved
          // ------------------------

          daum.maps.event.addListener(map, 'idle', function() {

            map.relayout();
            Message.loading();
            var currentCenter = {
              longitude: map.getCenter().getLng(),
              latitude: map.getCenter().getLat()
            };

            angular.extend(currentCenter, {
              distance: 2000,
              limit: 20
            });

            console.log(currentCenter);
            drawMarkers(currentCenter, markerImg, markerClickedImg, scope);

          });
        };
      }
    };
  }

})();

(function() {
    'use strict';
    angular.module('app')
        .factory('DaumMapModel', DaumMapModel);

    function DaumMapModel() {
        var model = {
            // need to specify category for search
            category: 'NAIL-PLACE', // only one category hence fixed
            currentPosition: {
                latitude: 'FLOAT',
                longitude: 'FLOAT'
            },
            markers: [],
            places: [],
            selectedPlace: {
                // response.places[n] selected from DaumMapDirective
            },
            modal: {
                //Defined in DaumMapController
            },
            findMeThenSearchNearBy: function(justFindDontDraw) {
                //Defined in DaumMapDirective
                console.log(justFindDontDraw + 'is a boolean to use outside map view');
            },
            searchLocationNearBy: function() {
                //Defined in DaumMapDirective
            },
        };

        return model;
    }
})();

(function() {
    'use strict';
    angular.module('app')
        .controller('EventRegisterController', EventRegisterController);

    EventRegisterController.$inject = ['EventRegisterModel'];

    function EventRegisterController(EventRegisterModel) {

        var EventRegister = this;
        EventRegister.Model = EventRegisterModel;


        //------------------------
        //  IMPLEMENTATIONS
        //------------------------
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('EventRegisterModel', EventRegisterModel);

    EventRegisterModel.$inject = [];

    function EventRegisterModel() {

        var model = {

        };
        return model;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .controller('LoginController', LoginController);

    LoginController.$inject = ['LoginModel', '$state', 'Users', 'Message', 'appStorage'];

    function LoginController(LoginModel, $state, Users, Message, appStorage) {

        var Login = this;
        Login.Model = LoginModel;

        Login.loginHandler = loginHandler;

        //------------------------
        //  IMPLEMENTATIONS
        //------------------------
        function loginHandler() {
            Message.loading();
            Users.login({}, {
                identifier: LoginModel.form.email,
                password: LoginModel.form.password
            }).$promise
                .then(function success(authData) {

                    appStorage.token = authData.token;
                    appStorage.user = authData.user;
                    return Users.getMyRole({}).$promise;

                }, function err(error) {

                    console.log(error);
                    Message.hide();
                    Message.alert('로그인 알림', '이메일이나 암호가 잘못 되었습니다.')
                        .then(function() {
                            LoginModel.form = {};
                        });
                    throw new Error('loginFail');

                })
                .then(function success(roleData) {

                    appStorage.role = roleData.name;
                    Message.hide();
                    $state.go('main.home.theme');

                }, function err(error) {

                    console.log(error);

                });
        }

        //------------------------
        //  HELPER
        //------------------------
    }

})();

(function() {
    'use strict';

    angular.module('app')
        .factory('LoginModel', LoginModel);

    function LoginModel() {

        var model = {
            form: {
                email: null,
                password: null
            }
        };
        return model;
    }

})();

(function() {
  'use strict';
  angular.module('app')
    .controller('MainController', MainController);

  MainController.$inject = ['MainModel', '$ionicSideMenuDelegate', 'appStorage', 'Message', '$ionicViewSwitcher', '$state', '$timeout'];

  function MainController(MainModel, $ionicSideMenuDelegate, appStorage, Message, $ionicViewSwitcher, $state, $timeout) {

    var Main = this;
    Main.Model = MainModel;

    Main.isBarAdmin = false;
    Main.isLoggedIn = false;
    Main.toggleSideMenu = toggleSideMenu;
    Main.logOut = logOut;
    Main.goToState = goToState;

    //------------------------
    //  IMPLEMENTATION
    //------------------------
    function goToState() {
      $ionicViewSwitcher.nextDirection('pop');
      $state.go('main.admin');
      $timeout(function() {
        $ionicSideMenuDelegate.toggleLeft(false);

      }, 300);
    }

    function toggleSideMenu() {
      if (appStorage.role === 'BAR_ADMIN' || appStorage.role === 'HUNGERS_ADMIN') {
        Main.isBarAdmin = true;
      } else {
        Main.isBarAdmin = false;
      }
      if (!appStorage.token) {
        // chnage text to login.
        Main.isLoggedIn = false;
      } else if (appStorage.token) {
        // change text to logout.
        Main.isLoggedIn = true;
      }

      $ionicSideMenuDelegate.toggleLeft();
    }

    function logOut() {
      Message.alert('로그아웃 알림', '로그아웃 하셨습니다.')
        .then(function() {
          delete appStorage.role;
          delete appStorage.user;
          delete appStorage.token;
          Main.isLoggedIn = false;
        });
    }


  }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('MainModel', MainModel);

    function MainModel() {

        var model = {};

        return model;

    }

})();

(function() {
  'use strict';

  angular.module('app')
    .controller('AssociationController', AssociationController);

  AssociationController = ['AssociationModel', '$state', 'Contacts', 'Message', 'appStorage'];

  function AssociationController(AssociationModel, $state, Contacts, Message, appStorage) {

    var Association = this;
    Association.Model = AssociationModel;

    Association.formHandler = formHandler;

    //------------------------
    //  IMPLEMENTATION
    //------------------------
    function formHandler() {
      if (!appStorage.role) {
        return Message.alert('제휴문의 알림', '로그인/회원가입을 하셔야 합니다.')
          .then(function() {
            $state.go('login');
          });
      }
      Message.loading();
      Contacts.contactAdmin({},
        formatForm(AssociationModel.form)
      ).$promise
        .then(function success() {
          AssociationModel.form = {};
          Message.hide();
          Message.alert('제휴문의 알림', '제휴문의가 성공적으로 접수 되었습니다. 가입하신 이메일로 연락 드리겠습니다.')
            .then(function() {
              $state.go('main.home.theme');
            });
        }, function err() {
          Message.hide();
          Message.alert('제휴문의 알림', '제목과 내용은 필수 사항입니다.');

        });

    }

    //------------------------
    //  HELPER
    //------------------------
    function formatForm(form) {
      var result = {};
      result.title = form.title;
      result.content = '<br>' + '업체명: ' + form.placeName + '<br>' +
        '전화번호: ' + form.phone + '<br>' +
        '지역: ' + form.location + '<br>' +
        '제목: ' + form.title + '<br>' +
        '내용: ' + form.content + '<br>';
      return result;
    }
  }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('AssociationModel', AssociationModel);

    function AssociationModel() {

        var model = {
            form: {
                placeName: null,
                phone: null,
                location: null,
                title: null,
                content: null
            }
        };
        return model;
    }
})();

(function() {
    'use strict';
    angular.module('app')
        .controller('CustomerController', CustomerController);

    CustomerController.$inject = ['CustomerModel', 'Contacts', '$state', 'Message', 'appStorage'];

    function CustomerController(CustomerModel, Contacts, $state, Message, appStorage) {
        var Customer = this;
        Customer.Model = CustomerModel;

        Customer.formHandler = formHandler;

        //------------------------
        //  IMPLEMENTATION
        //------------------------
        function formHandler() {
            if (!appStorage.role) {
                return Message.alert('고객센터 알림', '로그인/회원가입을 하셔야 합니다.')
                    .then(function() {
                        $state.go('login');
                    });
            }
            Message.loading();
            Contacts.contactAdmin({},
                CustomerModel.form
            ).$promise
                .then(function success() {
                    CustomerModel.form = {};
                    Message.hide();
                    Message.alert('고객문의 알림', '고객문의가 성공적으로 접수 되었습니다. 가입하신 이메일로 연락 드리겠습니다.')
                        .then(function() {
                            $state.go('main.home.theme');
                        });
                }, function err() {
                    Message.hide();
                    Message.alert('고객묵의 알림', '제목과 내용은 필수 사항입니다.');

                });

        }
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('CustomerModel', CustomerModel);



    function CustomerModel() {
        var model = {
            form: {
                email: null,
                phone: null,
                title: null,
                content: null
            }
        };
        return model;
    }
})();

(function() {
    'use strict';
    angular.module('app')
        .controller('EventController', EventController);

    EventController.$inject = ['EventModel'];

    function EventController(EventModel) {

        var Event = this;
        Event.Model = EventModel;


        //------------------------
        //  IMPLEMENTATIONS
        //------------------------
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('EventModel', EventModel);

    EventModel.$inject = [];

    function EventModel() {

        var model = {

        };
        return model;
    }
})();

(function() {
    'use strict';
    angular.module('app')
        .controller('EventDetailController', EventDetailController);

    EventDetailController.$inject = ['EventDetailModel', 'Posts', 'Message', '$stateParams',
        '$scope', '$ionicModal', 'Contacts', 'appStorage', '$state'
    ];

    function EventDetailController(EventDetailModel, Posts, Message, $stateParams, $scope, $ionicModal, Contacts, appStorage, $state) {

        var EventDetail = this;
        EventDetail.Model = EventDetailModel;
        EventDetail.isSelected = false;
        EventDetail.showTerms = false;
        EventDetail.sendForm = sendForm;


        $scope.$on('$ionicView.beforeEnter', onBeforeEnter);
        $scope.$on('$ionicView.afterEnter', onAfterEnter);
        //====================================================
        //  IMPLEMENTATION
        //====================================================
        function onBeforeEnter() {
            getAPost();
        }

        function onAfterEnter() {
            $ionicModal.fromTemplateUrl('state/mainEventDetail/eventRegisterModal.html', {
                scope: $scope,
                animation: 'slide-in-up'
            })
                .then(function(modal) {
                    EventDetail.modal = modal;
                });
        }

        function sendForm() {
            if (!appStorage.role) {
                return Message.alert('이벤트 응모 알림', '로그인/회원가입을 하셔야 합니다.')
                    .then(function() {
                        EventDetail.modal.hide();
                        $state.go('login');
                    });
            }
            if (!EventDetail.isSelected) {
                return Message.alert('이벤트 응모 알림', '약관에 동의 하여 주세요.');
            }
            EventDetailModel.form.content = EventDetailModel.post.summary;
            EventDetailModel.form.title = EventDetailModel.post.title;
            if (!EventDetailModel.form.name || !EventDetailModel.form.contact) {
                return Message.alert('이벤트 응모 알림', '이름과 연락처를 넣어주세요');
            }
            Message.loading();
            Contacts.contactAdmin({},
                EventDetailModel.form
            ).$promise
                .then(function success() {

                    EventDetailModel.form = {};
                    return Posts.likePost({
                        post: EventDetailModel.post.id
                    });

                }, function err() {

                    throw new Error('formFail');

                })
                .then(function success(postWrapper) {

                    if (postWrapper && postWrapper.posts[0]) {
                        EventDetailModel.post.likes = postWrapper.posts[0].likes;
                    }
                    Message.hide();
                    Message.alert('이벤트 응모 알림', '이벤트 응모가 성공적으로 접수되었습니다. 가입하신 이메일로 연락드리겠습니다.')
                        .then(function() {
                            EventDetail.modal.hide();
                        });

                }, function err(error) {

                    console.log(error);
                    Message.hide();
                    Message.alert('제휴문의 알림', '제목과 내용은 필수 사항입니다.');

                });

        }

        //====================================================
        //  HELPER
        //====================================================
        function getAPost() {
            Message.loading();
            Posts.findById({
                id: $stateParams.id,
                populates: 'photos'
            }).$promise
                .then(function success(postWrapper) {
                    console.log(postWrapper.post);
                    EventDetailModel.post = postWrapper.post;
                    Message.hide();
                    console.log('----------  ----------');
                    console.log(EventDetail.Model.post.photos[0]);
                    console.log('---------- CONSOLE END -------------------');

                }, function err(error) {
                    console.log(error);
                    Message.hide();
                    Message.alert('공지사항 알림', '없는 공지사항 입니다');
                });
        }
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('EventDetailModel', EventDetailModel);

    EventDetailModel.$inject = [];

    function EventDetailModel() {

        var model = {
            post: {},
            form: {
                title: '',
                content: '',
                name: '',
                contact: ''
            }
        };
        return model;
    }
})();

(function() {
  'use strict';
  angular.module('app')
    .controller('EventListController', EventListController);

  EventListController.$inject = ['EventListModel', 'Posts', '$stateParams', 'Message', '$scope'];

  function EventListController(EventListModel, Posts, $stateParams, Message, $scope) {

    var category = '';

    var EventList = this;
    EventList.Model = EventListModel;

    EventList.getOlderPosts = getOlderPosts;
    $scope.$on('$ionicView.beforeEnter', onBeforeEnter);
    $scope.$on('$ionicView.beforeLeave', onBeforeLeave);

    //====================================================
    //  IMPLEMENTATION
    //====================================================

    function onBeforeEnter() {
      if ($stateParams.eventType === 'hungersEvent') {
        category = 'HUNGERS-EVENT-POST';
      } else if ($stateParams.eventType === 'barEvent') {
        category = 'LIQUOR-EVENT-POST';
      }
      getPosts(category);
    }



    //====================================================
    //  HELPER
    //====================================================
    // category: 'HUNGERS-EVENT-POST',
    // category: 'LIQUOR-EVENT-POST',
    function getOlderPosts() {
      if ($stateParams.eventType === 'hungersEvent') {
        category = 'HUNGERS-EVENT-POST';
      } else if ($stateParams.eventType === 'barEvent') {
        category = 'LIQUOR-EVENT-POST';
      }
      var currentPosts = EventListModel.posts;
      Posts.getPosts({
        category: category,
        sort: 'id DESC',
        limit: 5,
        populates: 'photos',
        olderThan: currentPosts[currentPosts.length - 1].id
      }).$promise
        .then(function success(postsWrapper) {
          postsWrapper.posts.forEach(function(post) {
            currentPosts.push(post);
          });
          $scope.$broadcast('scroll.infiniteScrollComplete');
          EventListModel.more = postsWrapper.more;
        }, function err(error) {
          console.log(error);
          Message.alert();
          $scope.$broadcast('scroll.infiniteScrollComplete');
        });
    }

    function getPosts(category) {
      if (EventListModel.posts.length < 5) {
        Message.loading();
        return Posts.getPosts({
            category: category,
            sort: 'id DESC',
            limit: 5,
            populates: 'photos'
          }).$promise
          .then(function success(postsWrapper) {
            EventListModel.posts = postsWrapper.posts;
            EventListModel.more = postsWrapper.more;
            Message.hide();
          }, function err(error) {
            console.log(error);
            Message.alert();
            Message.hide();
          });
      }
    }

    function onBeforeLeave() {
      EventListModel.posts.length = 0;
    }

  }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('EventListModel', EventListModel);

    // EventListModel.$inject = [];

    function EventListModel() {

        var model = {
            posts: []
        };
        return model;
    }
})();

(function() {
    'use strict';
    angular.module('app')
        .controller('HomeController', HomeController);

    HomeController = ['HomeModel'];

    function HomeController(HomeModel) {

        var Home = this;
        Home.Model = HomeModel;

    }
})();

(function() {
    'use strict';
    angular.module('app')
        .factory('HomeModel', HomeModel);

    function HomeModel() {

        var model = {

        };

        return model;
    }
})();

(function() {
  'use strict';

  angular.module('app')
    .controller('LocationController', LocationController);

  LocationController.$inject = ['LocationModel', '$cordovaGeolocation', 'Message', '$scope', 'gpsService'];

  function LocationController(LocationModel, $cordovaGeolocation, Message, $scope, gpsService) {
    var Location = this;
    Location.Model = LocationModel;

    $scope.$on('$ionicView.enter', function() {
      gpsService.checkGPS();
    });
    //====================================================
    //  IMPLEMENTATION
    //====================================================
  }
})();

(function() {
    'use strict';
    angular.module('app')
        .factory('LocationModel', LocationModel);

    function LocationModel() {

        var model = {

        };
        return model;
    }
})();

(function() {
  'use strict';
  angular.module('app')
    .controller('TypeController', TypeController);

  TypeController.$inject = ['TypeModel', 'Message', '$cordovaGeolocation', '$scope', 'gpsService'];

  function TypeController(TypeModel, Message, $cordovaGeolocation, $scope, gpsService) {

    var Type = this;
    Type.Model = TypeModel;
    $scope.$on('$ionicView.enter', function() {
      gpsService.checkGPS();
    });
    //====================================================
    //  IMPLEMENTATION
    //====================================================

  }
})();

(function() {
    'use strict';
    angular.module('app')
        .factory('TypeModel', TypeModel);

    function TypeModel() {
        var model = {

        };

        return model;
    }
})();

(function() {
  'use strict';
  angular.module('app')
    .controller('ThemeController', ThemeController);

  ThemeController.$inject = ['ThemeModel', '$scope', 'Message', '$cordovaGeolocation', 'gpsService'];

  function ThemeController(ThemeModel, $scope, Message, $cordovaGeolocation, gpsService) {

    var Theme = this;
    Theme.Model = ThemeModel;

    $scope.$on('$ionicView.enter', function() {
      gpsService.checkGPS();
    });
  }
})();

(function() {
    'use strict';
    angular.module('app')
        .factory('ThemeModel', ThemeModel);

    function ThemeModel() {
        var model = {

        };

        return model;
    }

})();

(function() {
    'use strict';
    angular.module('app')
        .controller('NoticeDetailController', NoticeDetailController);

    NoticeDetailController.$inject = ['NoticeDetailModel', '$scope', 'Message', 'Places', '$stateParams', 'Posts'];

    function NoticeDetailController(NoticeDetailModel, $scope, Message, Places, $stateParams, Posts) {
        var NoticeDetail = this;
        NoticeDetail.Model = NoticeDetailModel;

        $scope.$on('$ionicView.beforeEnter', onBeforeEnter);

        //------------------------
        //  IMPLEMENTATION
        //------------------------
        function onBeforeEnter() {
            getAPost();
        }

        //------------------------
        //  HELPER
        //------------------------
        function getAPost() {
            Message.loading();
            Posts.get({
                id: $stateParams.id,
                populates: 'photos'
            }).$promise
                .then(function success(postWrapper) {
                    console.log(postWrapper);
                    NoticeDetailModel.post = postWrapper.post;
                    Message.hide();

                }, function err(error) {
                    console.log(error);
                    Message.hide();
                    Message.alert('공지사항 알림', '없는 공지사항 입니다');
                });
        }
    }
})();

(function() {
    'use strict';
    angular.module('app')
        .factory('NoticeDetailModel', NoticeDetailModel);

    function NoticeDetailModel() {
        var model = {
            currentPlace: {
                title: '헝거스 소비자 약관 변경 안내',
                createdAt: new Date()
            }
        };

        return model;
    }
})();

(function() {
    'use strict';
    angular.module('app')
        .controller('NoticeListController', NoticeListController);

    NoticeListController.$inject = ['NoticeListModel', 'Posts', '$state', '$scope', 'Message'];

    function NoticeListController(NoticeListModel, Posts, $state, $scope, Message) {

        var NoticeList = this;
        NoticeList.Model = NoticeListModel;

        NoticeList.getNewerPosts = getNewerPosts;
        NoticeList.getOlderPosts = getOlderPosts;
        NoticeList.checkForMore = checkForMore;

        $scope.$on('$ionicView.beforeEnter', onBeforeEnter);

        //------------------------
        //  IMPLEMENTATION
        //------------------------
        // Check for newer stuff;
        function getNewerPosts() {
            var currentPosts = NoticeListModel.postsWrapper.posts;
            return Posts.getPosts({
                    category: 'NOTICE-POST',
                    limit: 10,
                    newerThan: currentPosts[0].id
                }).$promise
                .then(function success(data) {
                    console.log(data);
                    if (!data.posts.length) {
                        Message.alert(
                            '새로운포스트가 없습니다',
                            '나중에 다시 확인해주세요'
                        );
                    }
                    data.posts.forEach(function(post) {
                        currentPosts.unshift(post);
                    });
                    $scope.$broadcast('scroll.refreshComplete');
                }, function err(error) {
                    console.log(error);
                    Message.alert();
                    $scope.$broadcast('scroll.refreshComplete');
                });
        }

        //  Check for older stuff
        function getOlderPosts() {
            var currentPosts = NoticeListModel.postsWrapper.posts;
            Posts.getPosts({
                category: 'NOTICE-POST',
                sort: 'id DESC',
                limit: 10,
                olderThan: currentPosts[currentPosts.length - 1].id
            }).$promise
                .then(function success(data) {
                    data.posts.forEach(function(post) {
                        currentPosts.push(post);
                    });
                    $scope.$broadcast('scroll.infiniteScrollComplete');
                    NoticeListModel.postsWrapper.more = data.more;
                }, function err(error) {
                    console.log(error);
                    Message.alert();
                    $scope.$broadcast('scroll.infiniteScrollComplete');
                });
        }

        function onBeforeEnter() {
            if (NoticeListModel.postsWrapper.posts.length < 10) {
                Message.loading();
                return Posts.getPosts({
                        category: 'NOTICE-POST',
                        sort: 'id DESC',
                        limit: 10
                        // , eager: true
                    }).$promise
                    .then(function success(data) {
                        console.log(data);
                        NoticeListModel.postsWrapper = data;
                        Message.hide();
                    }, function err(error) {
                        console.log(error);
                        Message.alert();
                        Message.hide();
                    });
            }
        }
        // Check if there is more data if none infinite-scroll is disabled.;
        function checkForMore() {
            return NoticeListModel.postsWrapper.more;
        }

    }
})();

(function() {
    'use strict';
    angular.module('app')
        .factory('NoticeListModel', NoticeListModel);

    function NoticeListModel() {
        var model = {
            postsWrapper: {
                posts: [{
                    title: '헝거스 약관변경안내',
                    content: '',
                    createdAt: new Date(),
                    category: '',
                    comments: [],
                    photos: [{
                        url: ''
                    }]
                }],
                more: false
            }
        };
        return model;
    }
})();

(function() {
  'use strict';
  angular.module('app')
    .controller('PlaceController', PlaceController);

  PlaceController.$inject = [
    'PlaceModel', 'Dom', '$ionicHistory', '$scope', '$stateParams', '$state', '_', '$ionicScrollDelegate',
    'appStorage'
  ];

  function PlaceController(
    PlaceModel, Dom, $ionicHistory, $scope, $stateParams, $state, _, $ionicScrollDelegate,
    appStorage
  ) {
    var Place = this;
    Place.Model = PlaceModel;

    Place.menuSelectHandler = menuSelectHandler;
    Place.getParams = getParams;
    Place.isLocation = isLocation;

    $scope.$on('$ionicView.afterEnter', onAfterEnter);

    //------------------------
    //  IMPLEMENTATION
    //------------------------
    function menuSelectHandler(arrayData, ionicScrollHandle, $index, item) {
      appStorage.scrollPositionY = 0;
      $state.go('main.place.list', {
        from: item.params.from
      });
      // Dom.menuScroller(arrayData, ionicScrollHandle, $index);
      PlaceModel.currentItem = item;
      console.log(PlaceModel.currentItem);
    }

    function getParams(param) {
      return $state.params[param];
    }

    function isLocation() {
      return $state.params.category === 'north' ||
        $state.params.category === 'south';
    }

    function onAfterEnter() {
      if ($stateParams.category === 'theme') {
        PlaceModel.currentCategory = PlaceModel.from.theme.category;
        // set currentItem to the one that is matching one of PlaceModel.from.theme.category
        angular.forEach(PlaceModel.currentCategory, function(obj) {
          var category = obj.params.from;
          if (category === $state.params.from) {
            PlaceModel.currentItem = obj;
          }
        });
      } else if ($stateParams.category === 'type') {
        PlaceModel.currentCategory = PlaceModel.from.type.category;
        angular.forEach(PlaceModel.currentCategory, function(obj) {
          var category = obj.params.from;
          if (category === $state.params.from) {
            PlaceModel.currentItem = obj;
          }
        });
      } else if ($stateParams.category === 'north' || $stateParams.category === 'south') {
        PlaceModel.currentCategory = PlaceModel.from.location.category;
        angular.forEach(PlaceModel.currentCategory, function(obj) {
          var category = obj.params.from;
          if (category === $state.params.from) {
            PlaceModel.currentItem = obj;
          }
        });
      } else {
        console.log('should not route back here');
      }
      moveIonScrollToCurrentIndex(PlaceModel.currentCategory);
    }

    //------------------------
    //  HELPER FUNCTIONS
    //------------------------



    function moveIonScrollToCurrentIndex(array) {
      var currentIndex = _.pluck(_.pluck(PlaceModel.currentCategory, 'params'), 'from')
        .indexOf($state.params.from);
      Dom.menuScroller(array, currentIndex, $ionicScrollDelegate);
      // Also set currentItem
      PlaceModel.currentItem = array[currentIndex];
    }
  }
})();

(function() {
  'use strict';
  angular.module('app')
    .factory('PlaceModel', PlaceModel);

  function PlaceModel() {

    var model = {
      from: {
        theme: {
          category: [{
            name: '헌팅',
            summary: '실시간 남녀성비가 제공되는 가장 Hot 한 헌팅 주점',
            params: {
              from: 'hunting',
              category: 'theme'
            },
            vw: 18.6
          }, {
            name: '데이트',
            summary: '연인 혹은 썸남썸녀를 위한 낭만적이고 로맨틱한 분위기의 주점',
            params: {
              from: 'romance',
              category: 'theme'
            },
            vw: 18.6
          }, {
            name: '친구',
            summary: '편안한 사람들과 부담 없이 한잔할 수 있는 주점',
            params: {
              from: 'friends',
              category: 'theme'
            },
            vw: 18.6
          }, {
            name: '이색',
            summary: '취향저격! 특별하고 유쾌한 이색 주점',
            params: {
              from: 'unique',
              category: 'theme'
            },
            vw: 18.6
          }, {
            name: '안주',
            summary: '특별한 안주와 곁들이면 맛과 분위기가 배가 되는 다이닝 주점',
            params: {
              from: 'dishes',
              category: 'theme'
            },
            vw: 18.6
          }, {
            name: '감성',
            summary: '추억을 자극하는 복고풍 분위기의 주점',
            params: {
              from: 'eighties',
              category: 'theme'
            },
            vw: 18.6
          }]
        },
        type: {
          category: [{
            name: '호프/포차',
            summary: '젊은 감성의 아지트, 한국식 소주 호프 & 포차',
            params: {
              from: 'pocha',
              category: 'type'
            },
            vw: 27
          }, {
            name: 'PUB',
            summary: '이국적인 분위기에서 다양한 주류 및 안주를 즐길 수 있는 서양식 주점',
            params: {
              from: 'pub',
              category: 'type'
            },
            vw: 18.6
          }, {
            name: '이자카야',
            summary: '맛, 술, 분위기 삼위일체의 정통 일본식 선술집',
            params: {
              from: 'izakaya',
              category: 'type'
            },
            vw: 25
          }, {
            name: 'BAR',
            summary: '특별한 데이트 혹은 친구들과의 특별한 만남을 위한 주점',
            params: {
              from: 'lounge',
              category: 'type'
            },
            vw: 18.6
          }, {
            name: '맥주',
            summary: '늦은 저녁 힘든 일과를 마치고 가볍게 한잔할 수 있는 맥주 전문점',
            params: {
              from: 'beer',
              category: 'type'
            },
            vw: 18.6
          }, {
            name: '민속/퓨전',
            summary: '비오는 날 생각나는 파전 & 막걸리 또는 특색 있는 안주의 향연이 있는 민속 & 퓨전 주점',
            params: {
              from: 'fusion',
              category: 'type'
            },
            vw: 25
          }]
        },
        location: {
          category: [{
            name: '홍대입구',
            summary: '',
            params: {
              from: 'hongdea',
              category: 'north'
            },
            vw: 25
          }, {
            name: '이태원',
            summary: '',
            params: {
              from: 'etehwon',
              category: 'north'
            },
            vw: 22
          }, {
            name: '건대입구',
            summary: '',
            params: {
              from: 'gundeaentrance',
              category: 'north'
            },
            vw: 25
          }, {
            name: '경리단길',
            summary: '',
            params: {
              from: 'gyungridangil',
              category: 'north'
            },
            vw: 25
          }, {
            name: '강남',
            summary: '',
            params: {
              from: 'gangnam',
              category: 'south'
            },
            vw: 18.6
          }, {
            name: '신논현',
            summary: '',
            params: {
              from: 'sinnonhyun',
              category: 'south'
            },
            vw: 22
          }, {
            name: '가로수길',
            summary: '',
            params: {
              from: 'garohsoogil',
              category: 'south'
            },
            vw: 25
          }, {
            name: '신림',
            summary: '',
            params: {
              from: 'shinrim',
              category: 'south'
            },
            vw: 18.6
          }]
        }

      },
      currentCategory: [],
      currentItem: {}
    };

    return model;
  }
})();

(function() {
  'use strict';
  angular.module('app')
    .controller('DetailController', DetailController);

  DetailController.$inject = ['DetailModel', '$stateParams', '$scope', 'Message',
    'Places', '$ionicSlideBoxDelegate', '$window', '$ionicModal', 'Posts', 'appStorage', 'moment', '$rootScope', '$ionicHistory', '$q', '$ionicScrollDelegate'
  ];

  function DetailController(DetailModel, $stateParams, $scope, Message, Places,
    $ionicSlideBoxDelegate, $window, $ionicModal, Posts, appStorage, moment, $rootScope, $ionicHistory, $q, $ionicScrollDelegate
  ) {
    var Detail = this;
    Detail.Model = DetailModel;

    Detail.callPhone = callPhone;
    Detail.showMenu = showMenu;
    Detail.openReview = openReview;
    Detail.isLoggedIn = isLoggedIn;
    Detail.isHuntingBar = isHuntingBar;
    Detail.hasPopularMenu = hasPopularMenu;
    Detail.hasSexPercentage = hasSexPercentage;
    Detail.goBack = goBack;

    $scope.$on('$ionicView.beforeEnter', onBeforeEnter);
    $scope.$on('$ionicView.enter', onEnter);
    $scope.$on('$ionicView.afterEnter', onAfterEnter);
    $scope.$on('$ionicView.beforeLeave', onBeforeLeave);

    //------------------------
    //  IMPLEMENTATION
    //------------------------
    function goBack() {
      appStorage.isBackViewDetail = true;
      $ionicHistory.goBack();
    }

    function hasPopularMenu() {
      var hasFood = Detail.Model.current.popularFood && Detail.Model.current.popularFood[0].name;
      var hasDrink = Detail.Model.current.popularDrink && Detail.Model.current.popularDrink[0].name;
      if (hasFood || hasDrink) {
        return true;
      } else {
        return false;
      }
    }

    function hasSexPercentage() {
      var hasMale = Detail.Model.current.male;
      var hasFemale = Detail.Model.current.female;
      if (hasMale || hasFemale) {
        return true;
      } else {
        return false;
      }
    }

    function isHuntingBar() {
      return DetailModel.current.tags.indexOf('헌팅') !== -1;
    }

    function isLoggedIn() {
      return !!appStorage.role;
    }

    function callPhone() {
      $window.location.href = 'tel:' + DetailModel.current.phone;
    }

    function openReview() {
      $window.open(DetailModel.current.reviewUrl, '_system');
    }

    function showMenu() {
      Detail.modal.show();
    }

    function onBeforeEnter() {
      $ionicScrollDelegate.$getByHandle('placeDetail').scrollTop();
      Detail.showPhotos = false;
      $rootScope.isTransitioning = true;
      reset();
      var loadPromise = loadPlace();
      getPostsByPlaceId($stateParams.id);
      Detail.month = moment().month() + 1;
      Detail.week = Math.ceil(moment().date() / 7);
      var deferred = $q.defer();
      deferred.resolve(loadPromise);
      return deferred.promise
        .then(function() {
          $ionicSlideBoxDelegate.update();
          $ionicSlideBoxDelegate.slide(0, 0);
          $ionicSlideBoxDelegate.enableSlide(true);
        });
    }

    function onAfterEnter() {
      Detail.showPhotos = true;
      console.log("---------- Detail.Model.current.updatedAt ----------");
      console.log(Detail.Model.current.updatedAt);
      console.log("HAS TYPE: " + typeof Detail.Model.current.updatedAt);

    }

    function onEnter() {
      // $ionicSlideBoxDelegate.update();
      // $ionicSlideBoxDelegate.slide(0, 0);
      // $ionicSlideBoxDelegate.enableSlide(true);
    }

    function onBeforeLeave() {
      $ionicSlideBoxDelegate.slide(0, 0);
      $ionicSlideBoxDelegate.update();
    }

    //------------------------
    //  HELPER
    //------------------------
    function reset() {
      DetailModel.current = {};
      DetailModel.current.photos = [];
      DetailModel.current.openingHours = [];
      DetailModel.current.tags = [];
      // DetailModel.posts = [];
    }

    function loadPlace() {
      Message.loading();
      return Places.findById({
          id: $stateParams.id,
          populates: 'photos,products'
        }).$promise
        .then(function success(place) {
          console.log("---------- place ----------");
          console.log(place);
          console.log("HAS TYPE: " + typeof place);

          DetailModel.current = place;
          Message.hide();

        }, function err(error) {
          console.log(error);
          Message.alert(
            '주점 알림',
            '요청하신 주점은 없는 주점입니다.'
          );
        });
    }

    function getPostsByPlaceId(id) {
      Message.loading();
      return Posts.getPosts({
          place: id
        }).$promise
        .then(function succes(postsWrapper) {
          DetailModel.posts = postsWrapper.posts;
          console.log('---------- postsWrapper ----------');
          console.log(postsWrapper);
          console.log('HAS TYPE: ' + typeof postsWrapper);
          console.log('---------- CONSOLE END -------------------');

        }, function err(error) {
          console.log('---------- error ----------');
          console.log(error);
          console.log('HAS TYPE: ' + typeof error);
          console.log('---------- CONSOLE END -------------------');

        });
    }

    //====================================================
    //  Modal
    //====================================================
    $ionicModal.fromTemplateUrl('state/mainPlaceDetail/menuModal.html', {
      scope: $scope,
      animation: 'slide-in-up'
    })
      .then(function(modal) {
        Detail.modal = modal;
      });


  } //Factory function

})();

(function() {
  'use strict';
  angular.module('app')
    .factory('DetailModel', DetailModel);


  function DetailModel() {

    var model = {
      current: {
        photos: [],
        name: '',
        address: '',
        openingHours: [],
        table: 0,
        male: '',
        female: '',
        summary: '',
        tags: [],
        updatedAt: ''
      },
      posts: []
    };
    return model;
  }
})();

(function() {
  'use strict';
  angular.module('app')
    .controller('PlaceListController', PlaceListController);

  PlaceListController.$inject = ['PlaceListModel', 'PlaceModel', 'Places', '$state', '$scope', '$stateParams', 'Message', '$cordovaGeolocation', 'Distance', '$ionicScrollDelegate', 'appStorage', '$ionicViewSwitcher'];

  function PlaceListController(PlaceListModel, PlaceModel, Places, $state, $scope, $stateParams, Message, $cordovaGeolocation, Distance, $ionicScrollDelegate, appStorage, $ionicViewSwitcher) {

    var PlaceList = this;
    PlaceList.Model = PlaceListModel;

    PlaceList.getFurtherPlaces = getFurtherPlaces;
    PlaceList.checkForMore = checkForMore;
    PlaceList.goToState = goToState;
    PlaceList.goHomeState = goHomeState;
    $scope.$on('$ionicView.beforeEnter', onBeforeEnter);

    //------------------------
    //  IMPLEMENTATION
    //------------------------
    function goHomeState() {
      $ionicViewSwitcher.nextDirection('back');
      if ($state.params.category === 'theme') {
        $state.go('main.home.theme');
      } else if ($state.params.category === 'type') {
        $state.go('main.home.type');
      } else if ($state.params.category === 'north' || $state.params.category === 'south') {
        $state.go('main.home.location');
      }
    }

    function goToState(place) {
      var scrollPos = $ionicScrollDelegate.$getByHandle('placeList').getScrollPosition();
      console.log("---------- scrollPos ----------");
      console.log(scrollPos);
      console.log("HAS TYPE: " + typeof scrollPos);
      appStorage.scrollPositionY = scrollPos.top;
      $state.go('main.detail', {
        id: place.id
      });
    }

    function getFurtherPlaces() {
      getNextPlacesWithinWithTags({
        tags: [$stateParams.from]
      });
    }

    function checkForMore() {
      return PlaceListModel.more;
    }

    function onBeforeEnter() {
      Message.loading();
      getPlacesWithinWithTags({
        tags: [$stateParams.from]
      });
    }

    //------------------------
    //  HELPER
    //------------------------
    function getPlacesWithinWithTags(tagsObj) {
      // if (U.areSiblingViews(['main.detail'])) {
      //   console.log("---------- 'main.detail' ----------");
      //   console.log('main.detail');
      //   console.log("HAS TYPE: " + typeof 'main.detail');

      //   return false;
      // }

      if (appStorage.isBackViewDetail) {
        appStorage.isBackViewDetail = false;
        Message.hide();
        return false;
      }
      PlaceListModel.places = [];
      PlaceListModel.more = false;
      // tagsObj={tags: ['hunting', 'romance', 'friends']};
      var tagsArray = tagsObj.tags; // tagsArray=['hunting', 'romance', 'friends'];
      var tagsArrayKorean = mapTagsToKorean(tagsArray); //tagsArrayKorean = ['헌팅', '감성', '친구'];
      var tagsCSVInKorean = tagsArrayKorean.join(','); //tagsCSVInKorean = '헌팅,감성,친구';

      $cordovaGeolocation.getCurrentPosition({
          maximumAge: 600000,
          timeout: 5000
        })
        .then(function success(position) {
          if (position.coords == null) {
            Message.hide();
            Message.alert(
              '위치 공유가 꺼져있습니다.',
              '위치 공유를 켜주세요.'
            );
            return false;
          }
          console.log(position.coords);
          return Places.getPlacesWithin({
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              distance: 300000,
              limit: 4,
              tags: tagsCSVInKorean,
              populates: 'photos'
            }).$promise
            .then(function success(placesWrapper) {
              PlaceListModel.currentLocation = [
                position.coords.longitude,
                position.coords.latitude
              ];
              angular.forEach(placesWrapper.places, function(place) {
                var distanceInMeters = distanceFromCurrentLocation(PlaceListModel.currentLocation, place.location.coordinates);
                place.distanceFromCurrent = distanceInMeters;
              });
              PlaceListModel.places = placesWrapper.places;
              PlaceListModel.more = placesWrapper.more;
              Message.hide();

              $ionicScrollDelegate.$getByHandle('placeList').resize();
              $scope.$broadcast('scroll.infiniteScrollComplete');

            }, function err(error) {
              console.log(error);
              Message.hide();
              Message.alert();
            });

        }, function error(err) {
          console.log(err);
          PlaceListModel.places = [];
          PlaceListModel.more = false;
          Message.hide();

          Places.getPlacesWithin({
              latitude: 37.498085435791786,
              longitude: 127.02800027507125,
              distance: 300000,
              limit: 4,
              tags: tagsCSVInKorean,
              populates: 'photos'
            }).$promise
            .then(function success(placesWrapper) {
              PlaceListModel.more = placesWrapper.more;
              PlaceListModel.currentLocation = [
                127.02800027507125,
                37.498085435791786
              ];
              angular.forEach(placesWrapper.places, function(place) {
                var distanceInMeters = distanceFromCurrentLocation(PlaceListModel.currentLocation, place.location.coordinates);
                place.distanceFromCurrent = distanceInMeters;
              });

              PlaceListModel.places = placesWrapper.places;
              Message.hide();

              $ionicScrollDelegate.$getByHandle('placeList').resize();
              $scope.$broadcast('scroll.infiniteScrollComplete');

            }, function err(error) {
              console.log(error);
              Message.hide();
              Message.alert();
            });
        });
    }

    function getNextPlacesWithinWithTags(tagsObj) {
      var tagsArray = tagsObj.tags; // tagsArray=['hunting', 'romance', 'friends'];
      var tagsArrayKorean = mapTagsToKorean(tagsArray); //tagsArrayKorean = ['헌팅', '감성', '친구'];
      var tagsCSVInKorean = tagsArrayKorean.join(','); //tagsCSVInKorean = '헌팅,감성,친구';

      $cordovaGeolocation.getCurrentPosition({
          maximumAge: 600000,
          timeout: 5000
        })
        .then(function success(position) {
          if (position.coords == null) {
            Message.hide();
            Message.alert(
              '위치 공유가 꺼져있습니다.',
              '위치 공유를 켜주세요.'
            );
            return false;
          }
          return Places.getPlacesWithin({
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              distance: 300000,
              skip: PlaceList.Model.places.length,
              limit: 4,
              tags: tagsCSVInKorean,
              populates: 'photos'
            }).$promise
            .then(function success(placesWrapper) {
              // Get distance from current location;
              PlaceListModel.more = placesWrapper.more;
              PlaceListModel.currentLocation = [
                position.coords.longitude,
                position.coords.latitude
              ];
              angular.forEach(placesWrapper.places, function(place) {
                var distanceInMeters = distanceFromCurrentLocation(PlaceListModel.currentLocation, place.location.coordinates);
                place.distanceFromCurrent = distanceInMeters;
              });
              // End;
              angular.forEach(placesWrapper.places, function(place) {
                PlaceListModel.places.push(place);
              });
              Message.hide();

              $ionicScrollDelegate.$getByHandle('placeList').resize();
              $scope.$broadcast('scroll.infiniteScrollComplete');

            }, function err(error) {
              console.log(error);
            });

        }, function error(err) {
          console.log(err);
          Message.hide();
          // Message.alert(
          //   '위치 공유가 꺼져있습니다.',
          //   '위치 공유를 켜주세요.'
          // );
          return Places.getPlacesWithin({
              latitude: 37.498085435791786,
              longitude: 127.02800027507125,
              distance: 300000,
              skip: PlaceListModel.places.length,
              limit: 4,
              tags: tagsCSVInKorean,
              populates: 'photos'
            }).$promise
            .then(function success(placesWrapper) {
              // Get distance from current location;
              PlaceListModel.more = placesWrapper.more;
              PlaceListModel.currentLocation = [
                127.02800027507125,
                37.498085435791786
              ];
              angular.forEach(placesWrapper.places, function(place) {
                var distanceInMeters = distanceFromCurrentLocation(PlaceListModel.currentLocation, place.location.coordinates);
                place.distanceFromCurrent = distanceInMeters;
              });
              angular.forEach(placesWrapper.places, function(place) {
                PlaceListModel.places.push(place);
              });
              Message.hide();

              $ionicScrollDelegate.$getByHandle('placeList').resize();
              $scope.$broadcast('scroll.infiniteScrollComplete');

            }, function err(error) {
              console.log(error);
            });
        });

    }


    //------------------------
    //  HELPER^2
    //------------------------
    function distanceFromCurrentLocation(currentCoord, placeCoord) {
      var p1 = {
        longitude: currentCoord[1],
        latitude: currentCoord[0]
      };
      var p2 = {
        longitude: placeCoord[1],
        latitude: placeCoord[0]
      };
      var distanceInMeters = Distance.between(p1, p2);
      return distanceInMeters;
    }

    function mapTagsToKorean(englishTags) {
      var mapperObjs = [{
        korean: '헌팅',
        english: 'hunting'
      }, {
        korean: '감성',
        english: 'eighties'
      }, {
        korean: '데이트',
        english: 'romance'
      }, {
        korean: '친구',
        english: 'friends'
      }, {
        korean: '이색',
        english: 'unique'
      }, {
        korean: '안주',
        english: 'dishes'
      }, {
        korean: '호프/포차',
        english: 'pocha'
      }, {
        korean: 'PUB',
        english: 'pub'
      }, {
        korean: '이자카야',
        english: 'izakaya'
      }, {
        korean: '맥주',
        english: 'beer'
      }, {
        korean: '민속/퓨전',
        english: 'fusion'
      }, {
        korean: 'BAR',
        english: 'lounge'
      }, {
        korean: '홍대',
        english: 'hongdea'
      }, {
        korean: '이태원',
        english: 'etehwon'
      }, {
        korean: '건대입구',
        english: 'gundeaentrance'
      }, {
        korean: '경리단길',
        english: 'gyungridangil'
      }, {
        korean: '강남',
        english: 'gangnam'
      }, {
        korean: '신논현',
        english: 'sinnonhyun'
      }, {
        korean: '가로수길',
        english: 'garohsoogil'
      }, {
        korean: '신림',
        english: 'shinrim'
      }];
      for (var i = 0; i < mapperObjs.length; i++) {
        var english = mapperObjs[i].english;
        var korean = mapperObjs[i].korean;
        for (var j = 0; j < englishTags.length; j++) {
          var englishTag = englishTags[j];
          if (englishTag === english) {
            englishTags.splice(j, 1, korean);
          }
        }
      }
      var convertedTagsArray = englishTags;
      return convertedTagsArray;
    }

  }
})();

(function() {
    'use strict';
    angular.module('app')
        .factory('PlaceListModel', PlaceListModel);

    function PlaceListModel() {
        var model = {
            places: [
                // {
                //     name: 'Hungers Bar',
                //     description: '',
                //     address: '서울특별시 마포구 서교동 342-2 2층',
                //     location: {
                //         type: 'Point',
                //         coordinates: [133, 11]
                //     },
                //     tags: ['헌팅최적화', '수제햄버거', '수제맥주', '다이닝펍'],
                //     photos: [{
                //         url: 'http://placehold.it/500x300'
                //     }]
                // }, {
                //     name: 'Magpie Brewing',
                //     description: '',
                //     address: '서울특별시 마포구 서교동 342-2 2층',
                //     location: {
                //         type: 'Point',
                //         coordinates: [133, 11]
                //     },
                //     tags: ['헌팅최적화', '수제햄버거', '수제맥주', '희귀맥주'],
                //     photos: [{
                //         url: 'http://placehold.it/500x300'
                //     }]

                // }, {
                //     name: 'I AM A HERO',
                //     description: '',
                //     address: '서울특별시 마포구 서교동 342-2 2층',
                //     location: {
                //         type: 'Point',
                //         coordinates: [133, 11]
                //     },
                //     tags: ['헌팅최적화', '수제햄버거', '수제맥주', '소맥'],
                //     photos: [{
                //         url: 'http://placehold.it/500x300'
                //     }]
                // }
            ],
            more: false
        };

        return model;
    }
})();

(function() {
  'use strict';
  angular.module('app')
    .controller('PlaceSearchController', PlaceSearchController);

  PlaceSearchController.$inject = ['PlaceSearchModel', 'PlaceModel', 'Places', '$state', '$scope', '$stateParams', 'Message', '$cordovaGeolocation', 'Distance', '$ionicScrollDelegate', 'daum'];

  function PlaceSearchController(PlaceSearchModel, PlaceModel, Places, $state, $scope, $stateParams, Message, $cordovaGeolocation, Distance, $ionicScrollDelegate, daum) {

    var PlaceSearch = this;
    PlaceSearch.Model = PlaceSearchModel;
    var lastSearchType = '';

    PlaceSearch.searchType = 'tag';
    PlaceSearch.getFurtherPlaces = getFurtherPlaces;
    PlaceSearch.checkForMore = checkForMore;
    PlaceSearch.searchLocationNearBy = searchLocationNearBy;
    PlaceSearch.setPlaceholderText = setPlaceholderText;
    $scope.$on('$ionicView.beforeEnter', onBeforeEnter);
    $scope.$on('$ionicView.leave', onLeave);

    //------------------------
    //  IMPLEMENTATION
    //------------------------
    //  Check for places further away;
    function getFurtherPlaces() {
      if (lastSearchType === 'address') {
        return getNextPlacesWithinByLocation(PlaceSearch.search);
      } else if (lastSearchType === 'placeName') {
        return getNextPlacesWithinByName(PlaceSearch.search);
      } else if (lastSearchType === 'tag') {
        var valueObj = {
          tags: [PlaceSearch.search]
        };
        return getNextPlacesWithinWithTags(valueObj);
      }
    }
    // Check if there is more data if none infinite-scroll is disabled.;
    function checkForMore() {
      return PlaceSearchModel.more;
    }

    function onBeforeEnter() {
      lastSearchType = '';
    }

    function onLeave() {
      lastSearchType = '';
    }

    function searchLocationNearBy(value) {
      $ionicScrollDelegate.$getByHandle('placeSearch').scrollTop(false);
      Message.loading();
      lastSearchType = 'tag';
      var valueObj = {
        tags: [value]
      };
      return getPlacesWithinWithTags(valueObj);

      // if (PlaceSearch.searchType === 'address') {
      //   lastSearchType = 'address';
      //   return getPlacesWithinByLocation(value);
      // } else if (PlaceSearch.searchType === 'placeName') {
      //   lastSearchType = 'placeName';
      //   return getPlacesWithinByName(value);
      // } else if (PlaceSearch.searchType === 'tag') {
      //   lastSearchType = 'tag';
      //   var valueObj = {
      //     tags: [value]
      //   };
      //   return getPlacesWithinWithTags(valueObj);
      // }
    }

    function setPlaceholderText() {
      if (PlaceSearch.searchType === 'address') {
        return '지역을 입력해주세요';
      } else if (PlaceSearch.searchType === 'placeName') {
        return '주점명을 입력해주세요';
      } else if (PlaceSearch.searchType === 'tag') {
        return '키워드를 입력해주세요';
      }
    }


    //------------------------
    //  HELPER
    //------------------------
    function getPlacesWithinByLocation(value) {
      var ps = new daum.maps.services.Places();
      if (!value) {
        Message.hide();
        Message.alert('통합검색 알림', '지역을 입력해주세요');
        return;
      }
      ps.keywordSearch(value, function(status, data) {
        // if no search result, notify and exit.
        if (data.places[0] === undefined) {
          Message.hide();
          Message.alert(
            '요청하신 장소가 없습니다',
            '다시검색해주세요'
          );
          return false;
        }

        return Places.getPlacesWithin({
            latitude: data.places[0].latitude,
            longitude: data.places[0].longitude,
            distance: 300000,
            limit: 4,
            populates: 'photos'
          }).$promise
          .then(function success(placesWrapper) {
            $cordovaGeolocation.getCurrentPosition({
              maximumAge: 600000,
              timeout: 5000
            })
              .then(function suc(position) {
                // Get distance from current location;
                PlaceSearchModel.currentLocation = [
                  position.coords.longitude,
                  position.coords.latitude
                ];
                angular.forEach(placesWrapper.places, function(place) {
                  var distanceInMeters = distanceFromCurrentLocation(PlaceSearchModel.currentLocation, place.location.coordinates);
                  place.distanceFromCurrent = distanceInMeters;
                });
                // End;
                PlaceSearchModel.places = placesWrapper.places;
                PlaceSearchModel.more = placesWrapper.more;
                Message.hide();

                $ionicScrollDelegate.$getByHandle('placeSearch').resize();
                $scope.$broadcast('scroll.infiniteScrollComplete');
              }, function er(error) {
                Message.alert(
                  '위치 공유가 꺼져있습니다.',
                  '위치 공유를 켜주세요.'
                );
                console.log(error);
                Message.hide();
              });
          }, function err(error) {
            console.log(error);
          });

      }, function(err) {
        console.log(err);
        Message.hide();
        Message.alert();
      });
    }

    function getNextPlacesWithinByLocation(value) {
      var ps = new daum.maps.services.Places();
      ps.keywordSearch(value, function(status, data) {

        // if no search result, notify and exit.
        if (data.places[0] === undefined) {
          Message.hide();
          Message.alert(
            '요청하신 장소가 없습니다',
            '다시검색해주세요'
          );
          return false;
        }

        return Places.getPlacesWithin({
            latitude: data.places[0].latitude,
            longitude: data.places[0].longitude,
            distance: 300000,
            skip: PlaceSearchModel.places.length,
            limit: 4,
            populates: 'photos'
          }).$promise
          .then(function success(placesWrapper) {
            $cordovaGeolocation.getCurrentPosition({
              maximumAge: 600000,
              timeout: 5000
            })
              .then(function suc(position) {
                // Get distance from current location;
                PlaceSearchModel.currentLocation = [
                  position.coords.longitude,
                  position.coords.latitude
                ];
                angular.forEach(placesWrapper.places, function(place) {
                  var distanceInMeters = distanceFromCurrentLocation(PlaceSearchModel.currentLocation, place.location.coordinates);
                  place.distanceFromCurrent = distanceInMeters;
                });
                // End;
                angular.forEach(placesWrapper.places, function(place) {
                  PlaceSearchModel.places.push(place);
                });

                PlaceSearchModel.more = placesWrapper.more;
                Message.hide();


                $ionicScrollDelegate.$getByHandle('placeSearch').resize();
                $scope.$broadcast('scroll.infiniteScrollComplete');

              }, function er(error) {
                Message.hide();
                Message.alert(
                  '위치 공유가 꺼져있습니다.',
                  '위치 공유를 켜주세요.'
                );
                console.log(error);
              });
          }, function err(error) {
            console.log(error);
          });

      }, function(err) {
        console.log(err);
        console.log(err);
        Message.hide();
        Message.alert();
      });
    }


    function getPlacesWithinByName(name) {
      $cordovaGeolocation.getCurrentPosition({
        maximumAge: 600000,
        timeout: 5000
      })
        .then(function success(position) {

          if (position.coords == null) {
            Message.hide();
            Message.alert(
              '위치 공유가 꺼져있습니다.',
              '위치 공유를 켜주세요.'
            );
            return false;
          }
          return Places.getPlacesWithin({
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              distance: 300000,
              limit: 4,
              filter: name,
              populates: 'photos'
            }).$promise
            .then(function success(placesWrapper) {
              // Get distance from current location;
              PlaceSearchModel.currentLocation = [
                position.coords.longitude,
                position.coords.latitude
              ];
              angular.forEach(placesWrapper.places, function(place) {
                var distanceInMeters = distanceFromCurrentLocation(PlaceSearchModel.currentLocation, place.location.coordinates);
                place.distanceFromCurrent = distanceInMeters;
              });
              // End;

              PlaceSearchModel.places = placesWrapper.places;
              PlaceSearchModel.more = placesWrapper.more;
              Message.hide();

              $ionicScrollDelegate.$getByHandle('placeSearch').resize();
              $ionicScrollDelegate.$getByHandle('placeSearch').scrollTop();


            }, function err(error) {
              console.log(error);
            });

        }, function err(error) {
          console.log(error);
          Message.hide();
          // Message.alert(
          //   '위치 공유가 꺼져있습니다.',
          //   '위치 공유를 켜주세요.'
          // );
          return Places.getPlacesWithin({
              latitude: 37.498085435791786,
              longitude: 127.02800027507125,
              distance: 300000,
              limit: 4,
              filter: name,
              populates: 'photos'
            }).$promise
            .then(function success(placesWrapper) {
              // Get distance from current location;
              PlaceSearchModel.currentLocation = [
                127.02800027507125,
                37.498085435791786
              ];
              angular.forEach(placesWrapper.places, function(place) {
                var distanceInMeters = distanceFromCurrentLocation(PlaceSearchModel.currentLocation, place.location.coordinates);
                place.distanceFromCurrent = distanceInMeters;
              });
              // End;

              PlaceSearchModel.places = placesWrapper.places;
              PlaceSearchModel.more = placesWrapper.more;
              Message.hide();

              $ionicScrollDelegate.$getByHandle('placeSearch').resize();
              $ionicScrollDelegate.$getByHandle('placeSearch').scrollTop();


            }, function err(error) {
              console.log(error);
            });

        });
      Message.hide();
    }


    function getNextPlacesWithinByName(name) {
      $cordovaGeolocation.getCurrentPosition({
        maximumAge: 600000,
        timeout: 5000
      })
        .then(function success(position) {

          if (position.coords == null) {
            Message.hide();
            Message.alert(
              '위치 공유가 꺼져있습니다.',
              '위치 공유를 켜주세요.'
            );
            return false;
          }
          return Places.getPlacesWithin({
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              distance: 300000,
              skip: PlaceSearch.Model.places.length,
              limit: 4,
              filter: name,
              populates: 'photos'
            }).$promise
            .then(function success(placesWrapper) {
              // Get distance from current location;
              PlaceSearchModel.currentLocation = [
                position.coords.longitude,
                position.coords.latitude
              ];
              angular.forEach(placesWrapper.places, function(place) {
                var distanceInMeters = distanceFromCurrentLocation(PlaceSearchModel.currentLocation, place.location.coordinates);
                place.distanceFromCurrent = distanceInMeters;
              });
              // End;
              angular.forEach(placesWrapper.places, function(place) {
                PlaceSearchModel.places.push(place);
              });
              PlaceSearchModel.more = placesWrapper.more;
              Message.hide();

              $ionicScrollDelegate.$getByHandle('placeSearch').resize();
              $scope.$broadcast('scroll.infiniteScrollComplete');

              // $ionicScrollDelegate.$getByHandle('placeSearch').scrollTop();


            }, function err(error) {
              console.log(error);
            });

        }, function err(error) {
          console.log(error);
          Message.hide();
          // Message.alert(
          //   '위치 공유가 꺼져있습니다.',
          //   '위치 공유를 켜주세요.'
          // );
          return Places.getPlacesWithin({
              longitude: 127.02800027507125,
              latitude: 37.498085435791786,
              distance: 300000,
              skip: PlaceSearch.Model.places.length,
              limit: 4,
              filter: name,
              populates: 'photos'
            }).$promise
            .then(function success(placesWrapper) {
              // Get distance from current location;
              PlaceSearchModel.currentLocation = [
                127.02800027507125,
                37.498085435791786
              ];
              angular.forEach(placesWrapper.places, function(place) {
                var distanceInMeters = distanceFromCurrentLocation(PlaceSearchModel.currentLocation, place.location.coordinates);
                place.distanceFromCurrent = distanceInMeters;
              });
              // End;
              angular.forEach(placesWrapper.places, function(place) {
                PlaceSearchModel.places.push(place);
              });
              PlaceSearchModel.more = placesWrapper.more;
              Message.hide();

              $ionicScrollDelegate.$getByHandle('placeSearch').resize();
              $scope.$broadcast('scroll.infiniteScrollComplete');

              // $ionicScrollDelegate.$getByHandle('placeSearch').scrollTop();


            }, function err(error) {
              console.log(error);
            });

        });
    }

    function getPlacesWithinWithTags(tagsObj) {
      // tagsObj={tags: ['hunting', 'romance', 'friends']};
      var tagsArray = tagsObj.tags; // tagsArray=['hunting', 'romance', 'friends'];
      var tagsArrayKorean = mapTagsToKorean(tagsArray); //tagsArrayKorean = ['헌팅', '감성', '친구'];
      var tagsCSVInKorean = tagsArrayKorean.join(','); //tagsCSVInKorean = '헌팅,감성,친구';

      $cordovaGeolocation.getCurrentPosition({
        maximumAge: 600000,
        timeout: 5000
      })
        .then(function success(position) {
          if (position.coords == null) {
            Message.hide();
            Message.alert(
              '위치 공유가 꺼져있습니다.',
              '위치 공유를 켜주세요.'
            );
            return false;
          }
          return Places.getPlacesWithin({
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              distance: 300000,
              limit: 4,
              tags: tagsCSVInKorean,
              populates: 'photos'
            }).$promise
            .then(function success(placesWrapper) {
              // Get distance from current location;
              PlaceSearchModel.currentLocation = [
                position.coords.longitude,
                position.coords.latitude
              ];
              angular.forEach(placesWrapper.places, function(place) {
                var distanceInMeters = distanceFromCurrentLocation(PlaceSearchModel.currentLocation, place.location.coordinates);
                place.distanceFromCurrent = distanceInMeters;
              });
              // End;

              PlaceSearchModel.places = placesWrapper.places;
              PlaceSearchModel.more = placesWrapper.more;
              Message.hide();


              $ionicScrollDelegate.$getByHandle('placeSearch').resize();
              // $ionicScrollDelegate.$getByHandle('placeSearch').scrollTop();


            }, function err(error) {
              console.log(error);
            });

        }, function error(err) {
          console.log(err);
          // Message.alert(
          //   '위치 공유가 꺼져있습니다.',
          //   '위치 공유를 켜주세요.'
          // );
          Message.hide();
          return Places.getPlacesWithin({
              longitude: 127.02800027507125,
              latitude: 37.498085435791786,
              distance: 300000,
              limit: 4,
              tags: tagsCSVInKorean,
              populates: 'photos'
            }).$promise
            .then(function success(placesWrapper) {
              // Get distance from current location;
              PlaceSearchModel.currentLocation = [
                127.02800027507125,
                37.498085435791786
              ];
              angular.forEach(placesWrapper.places, function(place) {
                var distanceInMeters = distanceFromCurrentLocation(PlaceSearchModel.currentLocation, place.location.coordinates);
                place.distanceFromCurrent = distanceInMeters;
              });
              // End;

              PlaceSearchModel.places = placesWrapper.places;
              PlaceSearchModel.more = placesWrapper.more;
              Message.hide();


              $ionicScrollDelegate.$getByHandle('placeSearch').resize();
              // $ionicScrollDelegate.$getByHandle('placeSearch').scrollTop();


            }, function err(error) {
              console.log(error);
            });

        });
      Message.hide();
    }

    function getNextPlacesWithinWithTags(tagsObj) {
      var tagsArray = tagsObj.tags; // tagsArray=['hunting', 'romance', 'friends'];
      var tagsArrayKorean = mapTagsToKorean(tagsArray); //tagsArrayKorean = ['헌팅', '감성', '친구'];
      var tagsCSVInKorean = tagsArrayKorean.join(','); //tagsCSVInKorean = '헌팅,감성,친구';

      $cordovaGeolocation.getCurrentPosition({
        maximumAge: 600000,
        timeout: 5000
      })
        .then(function success(position) {
          if (position.coords == null) {
            Message.hide();
            Message.alert(
              '위치 공유가 꺼져있습니다.',
              '위치 공유를 켜주세요.'
            );
            return false;
          }
          return Places.getPlacesWithin({
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              distance: 300000,
              skip: PlaceSearch.Model.places.length,
              limit: 4,
              tags: tagsCSVInKorean,
              populates: 'photos'
            }).$promise
            .then(function success(placesWrapper) {
              // Get distance from current location;
              PlaceSearchModel.currentLocation = [
                position.coords.longitude,
                position.coords.latitude
              ];
              angular.forEach(placesWrapper.places, function(place) {
                var distanceInMeters = distanceFromCurrentLocation(PlaceSearchModel.currentLocation, place.location.coordinates);
                place.distanceFromCurrent = distanceInMeters;
              });
              // End;
              angular.forEach(placesWrapper.places, function(place) {
                PlaceSearchModel.places.push(place);
              });
              PlaceSearchModel.more = placesWrapper.more;
              Message.hide();

              console.log('---------- PlaceSearchModel.places ----------');
              console.log(PlaceSearchModel.places);
              console.log('HAS TYPE: ' + typeof PlaceSearchModel.places);
              console.log('---------- CONSOLE END -------------------');

              $ionicScrollDelegate.$getByHandle('placeSearch').resize();
              $scope.$broadcast('scroll.infiniteScrollComplete');

              // $ionicScrollDelegate.$getByHandle('placeSearch').scrollTop();

            }, function err(error) {
              console.log(error);
            });

        }, function error(err) {
          console.log(err);
          Message.hide();
          // Message.alert(
          //   '위치 공유가 꺼져있습니다.',
          //   '위치 공유를 켜주세요.'
          // );
          return Places.getPlacesWithin({
              longitude: 127.02800027507125,
              latitude: 37.498085435791786,
              distance: 300000,
              skip: PlaceSearch.Model.places.length,
              limit: 4,
              tags: tagsCSVInKorean,
              populates: 'photos'
            }).$promise
            .then(function success(placesWrapper) {
              // Get distance from current location;
              PlaceSearchModel.currentLocation = [
                127.02800027507125,
                37.498085435791786
              ];
              angular.forEach(placesWrapper.places, function(place) {
                var distanceInMeters = distanceFromCurrentLocation(PlaceSearchModel.currentLocation, place.location.coordinates);
                place.distanceFromCurrent = distanceInMeters;
              });
              // End;
              angular.forEach(placesWrapper.places, function(place) {
                PlaceSearchModel.places.push(place);
              });
              PlaceSearchModel.more = placesWrapper.more;
              Message.hide();

              console.log('---------- PlaceSearchModel.places ----------');
              console.log(PlaceSearchModel.places);
              console.log('HAS TYPE: ' + typeof PlaceSearchModel.places);
              console.log('---------- CONSOLE END -------------------');

              $ionicScrollDelegate.$getByHandle('placeSearch').resize();
              $scope.$broadcast('scroll.infiniteScrollComplete');

              // $ionicScrollDelegate.$getByHandle('placeSearch').scrollTop();

            }, function err(error) {
              console.log(error);
            });
        });

    }


    //------------------------
    //  HELPER^2
    //------------------------
    function distanceFromCurrentLocation(currentCoord, placeCoord) {
      var p1 = {
        longitude: currentCoord[1],
        latitude: currentCoord[0]
      };
      var p2 = {
        longitude: placeCoord[1],
        latitude: placeCoord[0]
      };
      var distanceInMeters = Distance.between(p1, p2);
      return distanceInMeters;
    }

    function mapTagsToKorean(englishTags) {
      var mapperObjs = [{
        korean: '헌팅',
        english: 'hunting'
      }, {
        korean: '감성',
        english: 'eighties'
      }, {
        korean: '데이트',
        english: 'romance'
      }, {
        korean: '친구',
        english: 'friends'
      }, {
        korean: '이색',
        english: 'unique'
      }, {
        korean: '안주',
        english: 'dishes'
      }, {
        korean: '호프/포차',
        english: 'pocha'
      }, {
        korean: 'PUB',
        english: 'pub'
      }, {
        korean: '이자카야',
        english: 'izakaya'
      }, {
        korean: '맥주',
        english: 'beer'
      }, {
        korean: '민속/퓨전',
        english: 'fusion'
      }, {
        korean: 'BAR',
        english: 'lounge'
      }, {
        korean: '홍대',
        english: 'hongdea'
      }, {
        korean: '이태원',
        english: 'etehwon'
      }, {
        korean: '건대입구',
        english: 'gundeaentrance'
      }, {
        korean: '경리단길',
        english: 'gyungridangil'
      }, {
        korean: '강남',
        english: 'gangnam'
      }, {
        korean: '신논현',
        english: 'sinnonhyun'
      }, {
        korean: '가로수길',
        english: 'garohsoogil'
      }, {
        korean: '신림',
        english: 'shinrim'
      }];
      for (var i = 0; i < mapperObjs.length; i++) {
        var english = mapperObjs[i].english;
        var korean = mapperObjs[i].korean;
        for (var j = 0; j < englishTags.length; j++) {
          var englishTag = englishTags[j];
          if (englishTag === english) {
            englishTags.splice(j, 1, korean);
          }
        }
      }
      var convertedTagsArray = englishTags;
      return convertedTagsArray;
    }

  }
})();

(function() {
    'use strict';
    angular.module('app')
        .factory('PlaceSearchModel', PlaceSearchModel);

    function PlaceSearchModel() {
        var model = {
            places: [
                // {
                //     name: 'Hungers Bar',
                //     description: '',
                //     address: '서울특별시 마포구 서교동 342-2 2층',
                //     location: {
                //         type: 'Point',
                //         coordinates: [133, 11]
                //     },
                //     tags: ['헌팅최적화', '수제햄버거', '수제맥주', '다이닝펍'],
                //     photos: [{
                //         url: 'http://placehold.it/500x300'
                //     }]
                // }, {
                //     name: 'Magpie Brewing',
                //     description: '',
                //     address: '서울특별시 마포구 서교동 342-2 2층',
                //     location: {
                //         type: 'Point',
                //         coordinates: [133, 11]
                //     },
                //     tags: ['헌팅최적화', '수제햄버거', '수제맥주', '희귀맥주'],
                //     photos: [{
                //         url: 'http://placehold.it/500x300'
                //     }]

                // }, {
                //     name: 'I AM A HERO',
                //     description: '',
                //     address: '서울특별시 마포구 서교동 342-2 2층',
                //     location: {
                //         type: 'Point',
                //         coordinates: [133, 11]
                //     },
                //     tags: ['헌팅최적화', '수제햄버거', '수제맥주', '소맥'],
                //     photos: [{
                //         url: 'http://placehold.it/500x300'
                //     }]
                // }
            ],
            more: false
        };

        return model;
    }
})();

(function() {
  'use strict';
  angular.module('app')
    .controller('SignupController', SignupController);

  SignupController.$inject = ['SignupModel', 'Users', '$scope', '$state', 'Message', '$timeout'];

  function SignupController(SignupModel, Users, $scope, $state, Message, $timeout) {
    var Signup = this;
    Signup.Model = SignupModel;

    Signup.setSex = setSex;
    Signup.checkDuplicateNickname = checkDuplicateNickname;
    Signup.registerationHandler = registerationHandler;
    SignupModel.form.birthYear = null;

    $scope.$on('$ionicView.enter', onAfterEnter);
    $scope.$on('$ionicView.leave', onAfterEnter);

    //------------------------
    //  IMPLEMENTATION
    //------------------------
    function setSex(sex) {
      Signup.Model.form.sex = sex;
    }

    function checkDuplicateNickname(nickname) {
      Message.loading();
      Users.checkNickname({
        nickname: nickname
      }).$promise
        .then(function success(data) {
          Message.hide();
          if (data.isAvailable) {
            Message.alert('닉네임 알림', '사용가능한 닉네임 입니다');
            SignupModel.nickNameChecked = true;
          } else {
            Message.alert('닉네임 알림', '이미 사용중인 닉네임입니다, 다른 닉네임을 써주세요.');
            SignupModel.form.nickname = null;
            SignupModel.nickNameChecked = false;
          }

        }, function err(error) {
          console.log('---------- error ----------');
          console.log(error);
          console.log('HAS TYPE: ' + typeof error);
          console.log('---------- CONSOLE END -------------------');
          Message.hide();
        });
    }

    function registerationHandler() {
      // if (SignupModel.nickNameChecked === false) {
      //     return Message.alert('니네임 알림', '닉네임 중복을 확인해주세요');
      // }
      if (SignupModel.form.password !== SignupModel.form.passwordConfirm) {
        return Message.alert('비밀번호 알림', '비밀번호를 다시 한번 확인해주시고 입력해주세요');
      }
      Users.register({}, SignupModel.form).$promise
        .then(function success(data) {
          console.log('---------- data ----------');
          console.log(data);
          console.log('HAS TYPE: ' + typeof data);
          console.log('---------- CONSOLE END -------------------');
          angular.copy({
            birthYear: null
          }, SignupModel.form);
          Message.alert('회원가입 성공', '회원가입을 성공하였습니다.')
            .then(function(res) {
              console.log('---------- res ----------');
              console.log(res);
              console.log('HAS TYPE: ' + typeof res);
              console.log('---------- CONSOLE END -------------------');

              $state.go('login');
            });
          // SignupModel.form = {};

        }, function err(error) {
          console.log('---------- error ----------');
          console.log(error);
          console.log('HAS TYPE: ' + typeof error);
          console.log('---------- CONSOLE END -------------------');
          Message.hide();

          // var invalidAttributes = error.data.message.invalidAttributes;
          // if (invalidAttributes && invalidAttributes.nickname) {
          //     Message.alert('닉네임 알림', '닉네임이 짧습니다.');
          //     SignupModel.nickNameChecked = false;
          // } else {
          Message.alert('가입실패', '다시 입력해주세요');
          // }
        });
      // $state.go('main.home.theme');
    }

    function onAfterEnter() {
      $timeout(function() {
        angular.copy({
          email: null,
          nickname: null,
          password: null,
          passwordConfirm: null,
          birthYear: null,
          sex: null
        }, SignupModel.form);
        SignupModel.form.birthYear = null;
      }, 0);
    }
  }
})();

(function() {
  'use strict';
  angular.module('app')
    .factory('SignupModel', SignupModel);

  SignupModel.$inject = ['_', 'moment'];

  function SignupModel(_, moment) {

    var currentYear = moment().year();

    var years = _.range(currentYear - 90, currentYear + 1 - 18, 1);
    years = angular.forEach(years, function(year) {
      return String(year);
    });

    var model = {
      years: years,
      form: {
        email: null,
        nickname: null,
        password: null,
        passwordConfirm: null,
        birthYear: null,
        sex: null
      },
      nickNameChecked: false
    };

    return model;
  }
})();
